# 12.1 - Introduction to compound data types 复合数据类型简介

在 [[Chapter 4 - Fundamental Data Types#4.1 Introduction to fundamental data types 基本数据类型简介|4.1节——基本数据类型简介]] 中，我们介绍了基本数据类型，它们是C++作为核心语言的一部分提供的基础数据类型。

到目前为止，我们在程序中大量使用了这些基本类型，特别是`int`数据类型。虽然这些基本类型在简单使用时非常有用，但随着我们开始做更复杂的事情，它们无法满足我们的全部需求。

例如，假设你正在编写一个数学程序来讲两个分数相乘。你会如何在程序中表示一个分数？你可能会使用一对整数（一个表示分子，一个表示分母），就像这样：

```cpp
#include <iostream>

int main()
{
    // 我们的第一个分数
    int num1 {};
    int den1 {};

    // 我们的第二个分数
    int num2 {};
    int den2 {};

    // 用于移除分子和分母之间的斜杠
    char ignore {};

    std::cout << "输入一个分数: ";
    std::cin >> num1 >> ignore >> den1;

    std::cout << "输入一个分数: ";
    std::cin >> num2 >> ignore >> den2;

    std::cout << "两个分数相乘: "
        << num1 * num2 << '/' << den1 * den2 << '\n';

    return 0;
}
```

这个程序的运行结果：

``` plaintext
输入一个分数: 1/2
输入一个分数: 3/4
两个分数相乘: 3/8
```

虽然这个程序可以正常工作，但它带来了一些挑战需要我们改进。首先，每对整数之间的联系非常松散——除了注释和它们在代码中使用的上下文外，几乎没有什么提示说明每个分子和分母的配对是相关的。其次，遵循DRY（不要重复自己 don't repeat yourself）原则，我们应该创建一个函数来处理用户输入的分数（以及一些错误处理）。然而，函数只能返回一个值，那我们该如何将分子和分母返回给调用者呢？

现在想象另一种情况，你正在编写一个需要保存员工ID列表的程序。你可能会这样做：

```cpp
int main()
{
    int id1 { 42 };
    int id2 { 57 };
    int id3 { 162 };
    // and so on
}
```

但是如果你有100个员工呢？首先，你需要输入100个变量名。而如果你需要打印它们或传递给函数呢？我们将要输入大量的代码。这显然是不够灵活的。

显然，基本类型的应用是有限的。
## 复合数据类型

幸运的是，C++支持另一组数据类型，称为**复合数据类型(Compound data types)**。复合数据类型（有时也称为**复合类型(Composite data types)**）是可以由基本数据类型（或其他复合数据类型）构造的数据类型。每种复合数据类型也具有其独特的属性。

正如我们将在本章和后续章节中展示的那样，我们可以使用复合数据类型优雅地解决上述所有问题。

C++支持以下复合类型：
- 函数
- 数组
- 指针类型：
    - 指向对象的指针
    - 指向函数的指针
    - 指向成员类型的指针：
        - 指向数据成员的指针
        - 指向成员函数的指针
- 引用类型：
    - 左值引用
    - 右值引用
- 枚举类型：
    - 无作用域枚举
    - 有作用域枚举
- 类类型：
    - 结构体
    - 类
    - 联合体


你已经定期使用一种复合类型：函数。例如，考虑这个函数：

```cpp
void doSomething(int x, double y)
{
}
```

这个函数的类型是 `void(int, double)`。注意，这种类型是由基本数据类型组成的，因此它是一种复合类型。当然，函数还有其特殊的行为（例如，可以被调用）。

因为这里涉及的内容很多，我们会分多个章节来介绍。在本章中，我们将介绍一些较为直接的复合类型，包括**左值引用(`l-value references`)** 和**指针(`pointers`)** 。在下一章中，我们将介绍**无范围枚举(`unscoped enumerations`)**、**有范围枚举(`scoped enumerations`)** 和基本的**结构体(`structs`)** 。再往后的章节中，我们将引入类类型，并深入介绍一些更有用的**数组(`array`)**。这包括在 [[Chapter 5 - Constants and Strings#5.9 Introduction to `std string`|5.9 std::string 简介]] 中引入的 `std::string`，它实际上是一种类类型！

准备好了吗？让我们开始吧！
# 12.2 Value categories (lvalues and rvalues) 数值类型（左值和右值）

在我们讨论第一个复合类型（**左值引用**）之前，我们先来简单介绍一下什么是**左值(lvalue)**。

在[[Chapter 1 - C++ basics#1.10 Introduction to expressions|1.10节——表达式简介]]中，我们将表达式定义为：“由字面值、变量、运算符和函数调用组成的一个组合，可以执行以产生单一值”。

例如：

```cpp
#include <iostream>

int main()
{
    std::cout << 2 + 3 << '\n'; // 表达式 2 + 3 生成值 5

    return 0;
}
```

在上面的程序中，表达式 `2 + 3` 计算后值是 `5`，然后将其打印到控制台。

在[[Chapter 6 - Operators#6.4 Increment/decrement operators, and side effects|第6.4节——自增/自减运算符及副作用]]中，我们还提到表达式可以产生超出表达式本身的副作用：

``` cpp
#include <iostream>

int main()
{
    int x { 5 };
    ++x; // 这个表达式语句有副作用，x 的值增加了
    std::cout << x << '\n'; // 打印 6

    return 0;
}
```

在上面的程序中，表达式`++x`增加了`x`的值，并且在表达式结束后`x`仍然保持更改。

除了产生值和副作用之外，表达式还可以做一件事：它们可以求值为**对象(objects)** 或**函数(functions)**。我们稍后将深入探讨这一点。
## 表达式的属性

为了帮助确定表达式应该如何评估以及它们可以在何处使用，C++中的所有表达式都有两个属性：**类型**和**值类别**。
### 表达式的类型

表达式的**类型**等同于求值后生成的值、对象或函数的类型。例如：

``` cpp
int main()
{
    auto v1 { 12 / 4 }; // int / int => int
    auto v2 { 12.0 / 4 }; // double / int => double

    return 0;
}
```

对于 `v1`，编译器将在编译时确定，两个`int`操作数的除法将产生一个`int`结果，因此该表达式的类型是 `int`。通过类型推断，`v1` 的类型将被设为 `int`。

对于`v2`，编译器将在编译时确定，一个`double`操作数和一个`int`操作数的除法将产生一个`double`结果。记住，算术运算符必须有匹配类型的操作数，因此在这种情况下，`int` 操作数将被转换为 `double`，并执行浮点除法。因此，该表达式的类型为 `double`。

编译器可以使用表达式的类型来确定表达式在给定的上下文中是否有效。例如：

``` cpp
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print("foo"); // 错误：print() 期望一个 int 参数，我们传入了一个字符串字面值

    return 0;
}

```

在上面的程序中，`print(int)` 函数期望一个 `int` 参数。然而，我们传入的表达式（字符串字面值 `"foo"`）的类型不匹配，而且没有可以找到的转换。因此，产生编译错误。

注意，表达式的类型必须在编译时确定（否则类型检查和类型推断就无法工作）——然而，表达式的值可以在编译时（如果表达式是`constexpr`）或运行时（如果表达式不是`constexpr`）确定。
### 表达式的值类别

现在看一下这个程序：

``` cpp
int main()
{
    int x{};

    x = 5; // 有效：我们可以将 5 赋值给 x
    5 = x; // 错误：无法将 x 的值赋给字面值 5

    return 0;
}
```

其中，第一个赋值语句是有效的（将值 `5` 赋给变量 `x`），第二个则无效（将 `x` 的值赋给字面值 `5` 是没有意义的）。那么编译器如何知道哪些表达式可以合法地出现在赋值语句的两侧呢？

答案在于表达式的第二个属性：**值类别**。表达式（或子表达式）的**值类别**表示表达式解析为某种值、函数或某种对象。

在C++11之前，只有两种可能的值类别：**左值(lvalue)** 和 **右值(rvalue)**。

在 C++11 及以后，增加了三种额外的值类别：`glvalue`、`prvalue` 和 `xvalue` 以支持**移动语义(`move semantics`)** 这个新特性。

> [!note] 作者注
> 
> 在本课中，我们将坚持使用 C++11 之前的值类别观点，因为这更适合作为值类别的入门介绍（而且目前我们只需要这些内容）。我们将在以后的章节中讨论移动语义（以及新增的三种值类别）。
## 左值和右值表达式

**左值(`lvalue`)**（读作“ell-value”，是**左侧值(left value)** 或**定位值(locator value)** 的缩写，有时写作“l-value”）是一个计算为可识别的对象或函数（或位域）的表达式。

**"可识别性"(identity)** 是C++标准中使用的术语，但并没有明确定义。可识别的实体（例如对象或函数）可以与其他类似的实体区分开来（一般通过比较实体的地址）。

具有标识的实体可以通过标识符、引用或指针访问，通常其生命周期比单个表达式或语句更长。

``` cpp
int main()
{
    int x { 5 };
    int y { x }; // x 是一个左值表达式

    return 0;
}
```

在上面的程序中，表达式 `x` 是一个左值表达式，因为它求值为变量 `x`（它有一个标识符）。

自从引入常量以来，左值有了两种子类型：**可修改的左值(modifiable lvalue)** 是可以修改其值的左值。**不可修改的左值(non-modifiable lvalue)** 是不能修改其值的左值（因为该左值是 `const` 或 `constexpr`）。

``` cpp
int main()
{
    int x{};
    const double d{};

    int y { x }; // x 是一个可修改的左值表达式
    const double e { d }; // d 是一个不可修改的左值表达式

    return 0;
}
```

**右值(`rvalue`)**（读作“arr-value”，是**右侧值(right value)** 的缩写，有时写作“r-value”）指的是不属于左值的表达式。右值表达式解析为一个值。常见的右值包括字面值（除了 C 风格的字符串字面值，它们是左值）以及按值返回的函数和运算符的返回值。右值没有标识（这意味着它们必须立即使用），并且仅存在于它们被使用的表达式的范围内。

``` cpp
int return5()
{
    return 5;
}

int main()
{
    int x{ 5 }; // 5 是一个右值表达式
    const double d{ 1.2 }; // 1.2 是一个右值表达式

    int y { x }; // x 是一个可修改的左值表达式
    const double e { d }; // d 是一个不可修改的左值表达式
    int z { return5() }; // return5() 是一个右值表达式（因为结果按值返回）

    int w { x + 1 }; // x + 1 是一个右值表达式
    int q { static_cast<int>(d) }; // 对 d 的 static_cast 转换结果是一个右值表达式

    return 0;
}
```

你可能想知道为什么 `return5()`、`x + 1` 和 `static_cast<int>(d)` 是右值：答案是这些表达式产生了没有标识的临时值。

> [!example] 关键见解
> 
> **左值表达式**解析为一个具有标识的、可识别的对象。
> **右值表达式**解析为一个值。

现在我们可以回答为什么 `x = 5` 是有效的，而 `5 = x` 是无效的：赋值操作要求赋值的左操作数是一个**可修改的左值表达式**，而右操作数是一个**右值表达式**。后一个赋值（`5 = x`）失败是因为左操作数表达式 `5` 不是左值。

``` cpp
int main()
{
    int x{};

    // 赋值要求左操作数是一个可修改的左值表达式，右操作数是一个右值表达式
    x = 5; // 有效：x 是可修改的左值表达式，5 是右值表达式
    5 = x; // 错误：5 是右值表达式，x 是可修改的左值表达式

    return 0;
}
```

> [!info] 相关内容
>  
>  完整的左值和右值表达式可以在[这里](https://en.cppreference.com/w/cpp/language/value_category)找到。在C++11及以后，右值分成两个子类别：`prvalues`和`xvalues`，所以我们这里讨论的右值包含了这两者。

> [!info] 提示
> 
> 如果你不确定某个表达式是左值还是右值，尝试使用 `&` 运算符获取其地址，`&` 需要其操作数是左值。如果 `&(表达式)` 可以编译通过，表达式必须是左值：
> 
> ``` cpp
> int foo()
> {
>     return 5;
> }
> 
> int main()
> {
>     int x { 5 };
>     &x; // 可以编译：x 是左值表达式
>     &5; // 无法编译：5 是右值表达式
>     &foo(); // 无法编译：foo() 是右值表达式
> }
> ```

> [!example] 关键见解
> 
> C风格的字符串字面值是一个左值，因为C风格的字符串（即C风格的数组）会**退化(decay)** 为指针。退化过程只有在数组是左值（并且有一个可以存储在指针中的地址）时才有效。C++为了向后兼容继承了这一特性。
> 
> 我们会在 [17.8 -- C-style array decay](https://www.learncpp.com/cpp-tutorial/c-style-array-decay/) 中讨论数组退化。 
## 左值到右值的转换

让我们再次看一下这个例子：

``` cpp
int main()
{
    int x { 5 };
    int y { x }; // x 是一个左值表达式

    return 0;
}
```

如果 `x` 是求值为变量 `x` 的左值表达式，那么 `y` 是如何得到值 `5` 的呢？

答案是：在需要右值的上下文中，左值表达式会**隐式转换为右值表达式**。`int`变量的初始化期望是一个右值表达式。因此，左值表达式`x`会经历**左值到右值转换(lvalue-to-rvalue conversion)**，计算为值`5`，然后用于初始化`y`。

我们之前说过，赋值运算符要求右操作数是右值表达式，那么为什么像下面这样的代码可以正常工作呢？

``` cpp
int main()
{
    int x{ 1 };
    int y{ 2 };

    x = y; // y 是一个可修改的左值，不是右值，但这是合法的

    return 0;
}
```

在这种情况下，`y` 是一个左值表达式，但它经过了左值到右值的转换，求值为变量`y`的值（2），然后赋值给 `x`。

现在，考虑这个例子：

``` cpp
int main()
{
    int x { 2 };

    x = x + 1;

    return 0;
}
```

在这个语句中，变量 `x` 在两个不同的上下文中使用。在赋值运算符的左侧，`x` 是求值为变量 `x` 的左值表达式。在赋值运算符的右侧，`x + 1` 是求值为值 `3` 的右值表达式。

现在我们已经了解了左值，接下来可以讨论第一个复合类型：左值引用。

> [!example] 关键见解
> 
> 一个识别左值和右值表达式的经验法则：
> 
> - 左值表达式是那些解析为函数或可识别对象（包括变量）的表达式，这些对象在表达式结束后仍然存在。
> - 右值表达式是那些解析为值的表达式，包括字面值和在表达式结束后不再存在的临时对象。

# 12.3 Lvalue references 左值引用

在C++中，**引用(reference)** 是现有对象的别名。一旦定义了引用，对该引用的任何操作都会应用到所引用的对象上。

> [!example] 关键见解
>
> 本质上，引用与所引用的对象完全相同。

这意味着我们可以使用引用来读取或修改被引用的对象。尽管引用乍一看可能显得多余或无用，但它们在C++中被广泛使用（我们将在接下来的课程中看到许多例子）。

你也可以创建函数的引用，不过这较少使用。

现代C++包含两种类型的引用：**左值引用(lvalue reference)**和**右值引用(rvalue reference)**。在本章中，我们将讨论左值引用。

> [!info] 相关内容
>
> 由于我们将在本课中讨论左值和右值，如果你需要复习这些术语，请查看[[#12.2 Value categories (lvalues and rvalues) 数值类型（左值和右值）|12.2 —— 值类别（左值和右值）]]。右值引用将在[[Chapter 22 - Move Semantics and Smart Pointers|第22章]]关于移动语义的内容中介绍。

## 左值引用类型

**左值引用(lvalue reference)**（通常被简称为引用，因为在C++11之前只有一种引用类型）是现有左值（例如变量）的别名。

要声明一个左值引用类型，我们在类型声明中使用`&`符号：

```cpp
int // 一个普通的`int`类型 
int& // 一个指向`int`对象的左值引用 
double& // 一个指向`double`对象的左值引用
```

## 左值引用变量

左值引用类型的一个用途是创建**左值引用变量(lvalue reference variable)**。左值引用变量是一个充当某个左值（通常是另一个变量）引用的变量。

要创建左值引用变量，我们只需定义一个左值引用类型的变量：

```cpp
#include <iostream>

int main()
{
    int x { 5 };    // `x`是一个普通的整数变量
    int& ref { x }; // `ref`是一个左值引用变量，现在可以作为`x`的别名

    std::cout << x << '\n';  // 打印`x`的值 (5)
    std::cout << ref << '\n'; // 通过`ref`打印`x`的值 (5)

    return 0;
}
```

在上面的例子中，类型`int&`定义了`ref`作为一个指向`int`的左值引用，然后我们用左值表达式`x`来初始化它。从那时起，`ref`和`x`可以互换使用。因此，这个程序会输出：

``` plaintext
5
5
```

从编译器的角度来看，`&`符号是“附加”在类型名（`int& ref`）上还是变量名（`int &ref`）上无关紧要，如何选择取决于个人风格。现代C++程序员倾向于将`&`符号附加在类型名上，因为这样更清晰地表明引用是类型信息的一部分，而不是标识符。

> [!tip] 最佳实践
> 
> 当定义引用时，将`&`符号放在类型旁边（而不是引用变量的名称旁边）。

> [!info] 面向高级读者
> 
> 对于已经熟悉指针的人来说，这里的`&`符号并不表示“取地址”，而是表示“左值引用”。
## 通过左值引用修改值

在前面的例子中，我们展示了如何使用引用来读取被引用对象的值。我们也可以使用引用来修改被引用对象的值：

```cpp
#include <iostream>

int main()
{
    int x { 5 }; // 普通的整数变量
    int& ref { x }; // `ref`现在是`x`的别名

    std::cout << x << ref << '\n'; // 打印`55`

    x = 6; // `x`现在的值为6

    std::cout << x << ref << '\n'; // 打印`66`

    ref = 7; // 被引用的对象（`x`）现在的值为7

    std::cout << x << ref << '\n'; // 打印`77`

    return 0;
}
```

该代码输出：

``` plaintext
55
66
77
```

在上面的例子中，`ref`是`x`的别名，因此我们可以通过`x`或`ref`来改变`x`的值。
## 引用初始化

就像常量一样，所有的引用都必须初始化。引用使用一种称为**引用初始化(reference initialization)**的方式来进行初始化。

```cpp
int main()
{
    int& invalidRef;   // 错误：引用必须初始化

    int x { 5 };
    int& ref { x }; // 正确：`int`引用绑定到`int`变量

    return 0;
}
```

当引用被某个对象（或函数）初始化时，我们称其被**绑定(bound)** 到该对象（或函数）。这种引用被绑定的过程称为**引用绑定(reference binding)**。被引用的对象（或函数）有时被称为**被引用体(referent)**。

左值引用必须绑定到**可修改的左值**。

```cpp
int main()
{
    int x { 5 };
    int& ref { x }; // 有效：左值引用绑定到可修改的左值

    const int y { 5 };
    int& invalidRef { y };  // 无效：不能绑定到不可修改的左值
    int& invalidRef2 { 0 }; // 无效：不能绑定到右值

    return 0;
}
```

左值引用不能绑定到不可修改的左值或右值（否则你将能够通过引用修改这些值，这将违反它们的`const`特性）。因此，左值引用有时被称为“**指向非`const`的左值引用(non-const reference)**”。

在大多数情况下，引用的类型必须与被引用体的类型匹配。我们将在继承(`inheritance`)中讨论此规则的一些例外情况：

```cpp
int main()
{
    int x { 5 };
    int& ref { x }; // 正确：`int`引用绑定到`int`变量

    double y { 6.0 };
    int& invalidRef { y }; // 无效：`int`引用不能绑定到`double`变量
    double& invalidRef2 { x }; // 无效：`double`引用不能绑定到`int`变量

    return 0;
}
```

不允许存在指向`void`的左值引用（那有什么意义呢？）。
## 引用不能重新绑定（不能更改引用的对象）

一旦在C++中初始化了一个引用，它就不能被重新绑定，这意味着它不能被更改为引用另一个对象。

新手C++程序员通常试图通过赋值来重新绑定一个引用，将另一个变量赋给引用。这样做虽然可以编译并运行，但不会按预期工作。考虑以下程序：

```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { 6 };

    int& ref { x }; // `ref`现在是`x`的别名

    ref = y; // 将`y`的值（6）赋给`ref`（即被`ref`引用的对象`x`）
    // 上面的语句并没有将`ref`更改为引用变量`y`！

    std::cout << x << '\n'; // 你可能期望它打印5

    return 0;
}
```

令人惊讶的是，这将输出：

``` plaintext
6
```

当在表达式中计算引用时，它会解析为它所引用的对象。因此，`ref = y`并不会将`ref`更改为引用`y`。相反，因为`ref`是`x`的别名，这个表达式会被解释为`x = y`——由于`y`的值为6，因此`x`被赋值为6。
## 左值引用的作用域和生命周期

引用变量遵循与普通变量相同的作用域和生命周期规则：

```cpp
#include <iostream>

int main()
{
    int x { 5 }; // 普通整数
    int& ref { x }; // 引用变量

     return 0;
} // `x`和`ref`在这里销毁
```
## 引用和被引用体的独立生命周期

有一个例外（我们将在下一节讨论），引用的生命周期和其被引用对象的生命周期是独立的。换句话说，以下两种情况都可能成立：

- 引用可以在它引用的对象之前被销毁。
- 被引用的对象可以在引用之前被销毁。

当引用在被引用体之前被销毁时，被引用体不会受到影响。下面的程序演示了这一点：

```cpp
#include <iostream>

int main()
{
    int x { 5 };

    {
        int& ref { x };   // `ref`是`x`的引用
        std::cout << ref << '\n'; // 打印`ref`的值（5）
    } // `ref`在此处被销毁 —— `x`对此毫不知情

    std::cout << x << '\n'; // 打印`x`的值（5）

    return 0;
} // `x`在此处被销毁
```

上述程序的输出为：
``` plaintext
5
5
```

当`ref`被销毁时，变量`x`继续正常存在，完全不知道它的引用已经被销毁。
### 悬空引用

当被引用的对象在引用之前被销毁时，引用将指向一个不再存在的对象。这样的引用称为**悬空引用(dangling reference)**。访问悬空引用会导致未定义行为。

悬空引用相对容易避免，但我们将在 [[Chapter 12 - Compound Types - References and Pointers 复合类型 - 引用和指针#12.12 Return by reference and return by address|12.12节——通过引用返回值和通过地址返回值]] 中展示一个在实践中可能发生的案例。
### 引用不是对象

可能让人惊讶的是，引用在C++中并不是对象。引用不需要存在或占据存储空间。如果可能，编译器将通过用被引用体替换引用的所有出现来优化引用。然而，这并不总是可行，在某些情况下，引用可能需要存储空间。

这也意味着“引用变量”这个术语有点误导，因为变量是具有名称的对象，而引用并不是对象。

由于引用不是对象，它们不能在需要对象的任何地方使用（例如，你不能有一个引用的引用，因为左值引用必须引用一个可识别的对象）。在你需要一个作为对象的引用或可以重新绑定的引用的情况下，`std::reference_wrapper`（我们将在 [[Chapter 23 - Object Relationships#23.3 Aggregation|23.3节——聚合]] 中讨论）提供了一个解决方案。

> [!note] 顺带一提
> 
> 考虑以下变量：
> 
> ```cpp
> int var{};
> int& ref1{ var };  // 一个绑定到`var`的左值引用
> int& ref2{ ref1 }; // 一个绑定到`var`的左值引用
> ```
> 
> 由于`ref2`（一个引用）是用`ref1`（一个引用）初始化的，你可能会认为`ref2`是一个引用的引用。事实并非如此。因为`ref1`是`var`的引用，当在表达式中使用时（例如在初始化中），`ref1`会解析为`var`。因此，`ref2`只是一个普通的左值引用（其类型为`int&`），绑定到`var`。
> 
> **引用的引用**（指向`int`的引用）语法是`int&&`，但由于C++不支持引用的引用，这个语法在C++11中被重新用于表示**右值引用**（我们将在 [[Chapter 22 - Move Semantics and Smart Pointers#22.2 R-value references|22.2节——右值引用]] 中讨论）。

> [!note] 作者注
> 
> 如果此时你觉得引用有点没用，不用担心。引用在很多地方都会用到，我们将在 [[#12.5 Pass by lvalue reference|12.5节——通过左值引用传递]] 和 [[#12.6 Pass by const lvalue reference|12.6节——通过`const`左值引用传递]] 中很快介绍它的主要用法。
## 小测

> [!question] Q1. 请自己确定以下程序的输出值（不要编译程序）。
> 
> ```cpp
> int main()
> {
>     int x{ 1 };
>     int& ref{ x };
> 
>     std::cout << x << ref << '\n';
> 
>     int y{ 2 };
>     ref = y;
>     y = 3;
> 
>     std::cout << x << ref << '\n';
> 
>     x = 4;
> 
>     std::cout << x << ref << '\n';
> 
>     return 0;
> }
> ```

> [!tip]- A1. 答案
> ``` plaintext
> 11  
> 22  
> 44
> ```
> 
> 因为`ref`绑定到`x`，所以`x`和`ref`是同义的，因此它们总是打印相同的值。`ref = y`这行代码将`y`的值（2）赋给`ref`，而不是将`ref`更改为引用`y`。随后的`y = 3`只会更改`y`的值。
# 12.4 Lvalue references to const
# 12.5 Pass by lvalue reference
# 12.6 Pass by const lvalue reference
# 12.7 Introduction to pointers
# 12.8 Null pointers
# 12.9 Pointers and const
# 12.10 Pass by address
# 12.11 Pass by address (part 2)
# 12.12 Return by reference and return by address
# 12.13 In and out parameters
# 12.14 Type deduction with pointers, references, and const
# 12.15 `std::optional`
# 12.x Chapter 12 summary and quiz

