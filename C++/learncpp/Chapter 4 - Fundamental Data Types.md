# 4.1 Introduction to fundamental data types 基本数据类型简介
## 位、字节和内存寻址
在[[Chapter 1 - C++ basics#1.3 - Introduction to objects and variables 对象和变量简介|1.3 — 对象和变量简介]]中，我们讨论了变量是用于存储信息的一块内存的名称。简单回顾一下，计算机拥有可供程序使用的**随机存取内存**（Random Access Memory, RAM）。当定义一个变量时，系统会为该变量分配一块内存。

**内存**的最小单位是**二进制位**（也称为**比特**），它可以存储 0 或 1 的值。你可以将比特想象成传统的电灯开关——要么是关（0），要么是开（1），没有中间状态。如果你查看某段内存，看到的可能是这样的一串数：`011010100101010`，或类似的组合。

**内存**被组织成**顺序单元**，称为**内存地址**（简称为地址）。就像街道地址可以用来找到街道上的某一所房子一样，**内存地址**使我们能够找到并访问位于特定位置的内存内容。

可能令人惊讶的是，在现代计算机架构中，每个位并没有自己的唯一内存地址。这是因为内存地址的数量有限，而按位访问数据的需求也较为罕见。相反，每个**内存地址**存储 **1 字节** 的数据。**字节**是一组比特，作为一个整体进行操作。现代标准规定一个字节由**8 个连续的比特**组成。

> **关键见解**
> 
> 在 C++ 中，我们通常处理的是以“字节”为单位的数据。

下图展示了一些连续的**内存地址**及其对应的字节数据：
![内存寻址](https://www.learncpp.com/images/CppTutorial/Section2/MemoryAddresses.png?ezimgfmt=rs%3Adevice%2Frscb2-1)

> 顺便一提……
> 
> 一些较早或非标准的机器可能会有不同大小的字节（从 1 到 48 比特不等），但我们通常不必担心这些问题，因为现代默认标准是 **1 字节 = 8 比特**。在这些教程中，我们将假设一个字节是 **8 比特**。

### 数据类型

由于计算机上的所有数据都只是比特的序列，我们使用**数据类型**（简称为“类型”）来告诉编译器如何以有意义的方式解释内存中的内容。你已经见过一个数据类型的例子：**整数**。当我们声明一个变量为整数时，我们就是在告诉编译器“这个变量使用的内存将被解释为整数值”。

当你给一个对象赋值时，编译器和 CPU 会负责将你的值编码为适合该数据类型的比特序列，并将这些比特存储在内存中（记住：内存只能存储比特）。例如，如果你将整数对象赋值为`65`，这个值会被转换为比特序列 `0100 0001`，并存储在分配给该对象的内存中。

相反，当对象被评估以产生一个值时，这段比特序列会被重新构建回原始值。也就是说，`0100 0001`会被转换回`65`。

幸运的是，编译器和 CPU 会完成所有这些繁重的工作，因此你通常不需要担心值如何被转换为比特序列以及如何恢复。

你需要做的就是为对象选择一个最符合你预期用途的**数据类型**。
## 基本数据类型

C++ 预置了对许多不同数据类型的支持。这些被称为**基本数据类型**，但通常也被非正式地称为**基础类型**(`basic types`)、**原始类型**(`primitive types`)或**内置类型**(`built-in types`)。

以下是基本数据类型的列表，其中一些你已经见过了：

| 类型                       | 类别      | 含义          | 示例        |
| ------------------------ | ------- | ----------- | --------- |
| `float`                  | 浮点型     | 带有小数部分的数字   | 3.14159   |
| `double`                 | 浮点型     | 带有小数部分的数字   | 3.14159   |
| `long double`            | 浮点型     | 带有小数部分的数字   | 3.14159   |
| `bool`                   | 整型（布尔型） | 真或假         | `true`    |
| `char`                   | 整型（字符型） | 一个文本字符      | `'c'`     |
| `wchar_t`                | 整型（字符型） | 宽字符         | `'c'`     |
| `char8_t` (C++20)        | 整型（字符型） | UTF-8 编码字符  | `'c'`     |
| `char16_t` (C++11)       | 整型（字符型） | UTF-16 编码字符 | `'c'`     |
| `char32_t` (C++11)       | 整型（字符型） | UTF-32 编码字符 | `'c'`     |
| `short int`              | 整型（整数型） | 正负整数，包括 0   | `64`      |
| `int`                    | 整型（整数型） | 正负整数，包括 0   | `64`      |
| `long int`               | 整型（整数型） | 正负整数，包括 0   | `64`      |
| `long long int` (C++11)  | 整型（整数型） | 更大的正负整数     | `64`      |
| `std::nullptr_t` (C++11) | 空指针     | 一个空指针       | `nullptr` |
| `void`                   | 空类型     | 无类型         | n/a       |

本章将详细探讨这些基本数据类型（除了 `std::nullptr_t`，我们会在讨论指针时再介绍）。C++ 还支持许多其他更复杂的类型，称为**复合类型**。我们将在后续章节中探讨复合类型。

> **作者注**
> 
> 术语“**整数**”（**integer**）和“**整型**”（**integral**）相似，但有时含义不同。
> 
> 在数学中，整数是没有小数或小数部分的数字，包括正数、负数和零。
> 
> 在 C++ 中，**integer** 术语最常用来指代 `int` 数据类型，它存储整数值。然而，它有时也用于指代常用于存储和显示整数值的更广泛的数据类型。这包括 `short`、`int`、`long`、`long long` 及其带符号和无符号变体。
> 
> 术语“**整型**”（**integral**）表示“像整数一样”。整型通常是术语“**整型类型**”（**integral type**）的一部分，它包括以整数形式存储在内存中的更广泛的类型，即使它们的行为可能有所不同（我们将在本章稍后讨论字符类型时看到）。这包括 `bool`、整数类型以及各种字符类型。

> **顺便一提……**
> 
> 大多数现代编程语言都包括一个基本的**字符串类型**（字符串是一种允许我们保存字符序列的数据类型，通常用于表示文本）。在 C++ 中，**字符串** 不是基本类型（它们是复合类型）。但是，由于基本的字符串用法非常简单且有用，我们将在下节[[Chapter 5 - Constants and Strings#5.9 Introduction to `std string`|5.9 — std::string 简介]]中介绍字符串。
## `_t` 后缀
C++ 新版本定义的许多类型（例如 `std::nullptr_t`）使用了 `_t` 后缀。这个后缀表示“类型”（**type**），它是现代类型命名中常见的惯例。

如果你看到某个名称带有 `_t` 后缀，它可能是一个类型。但很多类型没有 `_t` 后缀，所以这种命名惯例并不总是一致的。
# 4.2 Void
`void` 是最容易解释的数据类型。基本上，`void` 的意思是“无类型”！

`void` 是我们遇到的第一个**不完整类型**（**incomplete type**）的例子。**不完整类型**是指已被声明但尚未定义的类型。编译器知道这类类型的存在，但没有足够的信息来确定为该类型的对象分配多少内存。`void` 是故意不完整的，因为它代表缺少类型，因此不能被定义。

**不完整类型**无法被实例化：

```cpp
void value; // 这将不起作用，无法用不完整类型 void 定义变量
```

`void` 通常在多种不同的情景中使用
## 不返回值的函数

最常见的是，`void` 用来表示函数不返回值：

```cpp
void writeValue(int x) // 这里的 void 表示没有返回值
{
    std::cout << "x 的值是: " << x << '\n';
    // 没有 return 语句，因为这个函数不返回值
}
```

如果你在这样的函数中使用 `return` 语句来尝试返回一个值，会产生编译错误：

```cpp
void noReturn(int x) // 这里的 void 表示没有返回值
{
    std::cout << "x 的值是: " << x << '\n';

    return 5; // 错误
}
```

在 Visual Studio 2017 上，这会产生如下错误：

```plaintext
error C2562: 'noReturn': 'void' function returning a value
```

## 已弃用：没有参数的函数

在 C 语言中，`void` 被用作表示函数没有任何参数的一种方式：

```cpp
int getValue(void) // 这里的 void 表示没有参数
{
    int x{};
    std::cin >> x;

    return x;
}
```

虽然这在 C++ 中仍然可以编译（出于向后兼容的原因），但在 C++ 中这种使用 `void` 的方式被认为是已弃用的。以下代码是等价的，并且在 C++ 中是推荐的写法：

```cpp
int getValue() // 空的函数参数列表隐含为 void
{
    int x{};
    std::cin >> x;

    return x;
}
```

> 最佳实践
> 
> 使用空的参数列表而不是 `void` 来表示函数没有参数。

## `void` 的其他用途

`void` 关键字在 C++ 中还有第三种（更高级）用途，我们将在[[Chapter 19 - Dynamic Allocation#19.5 Void pointers|19.5 — `void` 指针]]中讨论。因为我们尚未介绍指针的概念，现在你不必担心这种情况。

让我们继续前进吧！

# 4.3 Object sizes and the `sizeof` operator
## 对象大小

在[[#4.1 Introduction to fundamental data types 基本数据类型简介|4.1 — 基本数据类型简介]]中，我们了解到现代机器的内存通常被组织成字节大小的单元，每个内存字节都有一个唯一的地址。到目前为止，你可以将内存想象为可以存储和检索信息的储物格或信箱，而变量是访问这些储物格或信箱的名称，这种类比可以帮助你理解变量和内存的关系。

然而，这个类比在某个方面并不完全正确——大多数对象实际上占用的不仅仅是 1 个字节的内存。一个对象可能使用 1、2、4、8 或更多的连续内存地址。对象使用的内存量取决于它的数据类型。

因为我们通常通过变量名访问内存（而不是直接通过内存地址），编译器能够隐藏给定对象使用了多少字节的细节。当我们访问某个变量 `x` 时，编译器知道需要检索多少字节的数据（基于变量 `x` 的类型），并可以为我们处理这一任务。

尽管如此，了解对象使用多少内存还是有一些用处的。

首先，对象使用的内存越多，它可以存储的信息就越多。

一个位（bit）可以存储 2 个可能的值，即 0 或 1：

| 位 0 | 值 |
|-----|----|
| 0   | 0  |
| 1   | 1  |

2 位可以存储 4 个可能的值：

| 位 0 | 位 1 | 值 |
|-----|------|----|
| 0   | 0    | 0  |
| 0   | 1    | 1  |
| 1   | 0    | 2  |
| 1   | 1    | 3  |

3 位可以存储 8 个可能的值：

| 位 0 | 位 1 | 位 2 | 值 |
|-----|------|------|----|
| 0   | 0    | 0    | 0  |
| 0   | 0    | 1    | 1  |
| 0   | 1    | 0    | 2  |
| 0   | 1    | 1    | 3  |
| 1   | 0    | 0    | 4  |
| 1   | 0    | 1    | 5  |
| 1   | 1    | 0    | 6  |
| 1   | 1    | 1    | 7  |

可以概括为，一个拥有 `n` 位的对象可以存储 **2^n** 个唯一值。因此，一个 8 位（bit）的字节可以存储 **2^8**（即 256）个不同的值。一个使用 2 个字节的对象可以存储 **2^16**（即 65536）个不同的值！

因此，**对象的大小限制了它可以存储的唯一值的数量**——使用更多字节的对象可以存储更多的唯一值。我们将在讨论整数时进一步探讨这一点。

其次，计算机的可用内存是有限的。每次定义一个对象时，只要该对象存在，就会占用一小部分可用内存。由于现代计算机拥有大量内存，这种影响通常可以忽略不计。然而，对于需要大量对象或数据的程序（例如渲染数百万多边形的游戏），使用 1 字节和 8 字节对象之间的差异可能非常显著。

> **关键见解**
> 
> 新程序员往往过于关注优化代码以尽可能少地使用内存。在大多数情况下，这种优化的效果微不足道。**应专注于编写可维护的代码，只有在优化能带来实质性好处时才考虑优化**。

## 基本数据类型的大小

显然，下一个问题是：“不同数据类型的变量占用多少内存？”。

可能令人惊讶的是，C++ 标准并没有定义任何基本类型的确切大小（以位为单位）。`char` 必须是 1 个字节，但并未假定字节一定是 8 位。整型类型有一个最小大小（以位为单位），但可以更大。

在本教程系列中，我们将采用简化的视角，做出一些对现代架构通常成立的合理假设：

- 一个字节等于 8 位。
- 内存是按字节寻址的，因此最小的对象是 1 个字节。
- 浮点数支持 IEEE-754 标准。
- 我们处于 32 位或 64 位架构上。

基于此，我们可以得出以下结论：

| 类别          | 类型           | 最小大小     | 典型大小       | 备注                     |
|---------------|----------------|--------------|----------------|--------------------------|
| 布尔型        | `bool`         | 1 字节       | 1 字节         |                          |
| 字符型        | `char`         | 1 字节       | 1 字节         | 始终为 1 字节             |
|               | `wchar_t`      | 1 字节       | 2 或 4 字节    |                          |
|               | `char8_t`      | 1 字节       | 1 字节         |                          |
|               | `char16_t`     | 2 字节       | 2 字节         |                          |
|               | `char32_t`     | 4 字节       | 4 字节         |                          |
| 整数型        | `short`        | 2 字节       | 2 字节         |                          |
|               | `int`          | 2 字节       | 4 字节         |                          |
|               | `long`         | 4 字节       | 4 或 8 字节    |                          |
|               | `long long`    | 8 字节       | 8 字节         |                          |
| 浮点型        | `float`        | 4 字节       | 4 字节         |                          |
|               | `double`       | 8 字节       | 8 字节         |                          |
|               | `long double`  | 8 字节       | 8、12 或 16 字节 |                          |
| 指针类型      | `std::nullptr_t`| 4 字节       | 4 或 8 字节    |                          |
 
> **提示**
> 
> 为了最大程度的可移植性，**你不应该假设变量比指定的最小大小更大**。
> 
> 或者，如果你想假设某个类型具有某种大小（例如假设 `int` 至少是 4 字节），可以使用 `static_assert`，如果该假设在某些架构上不成立，编译器将无法编译通过。我们将在[[Chapter 9 -  Error Detection and Handling#9.6 Assert and static_assert|9.6 — Assert 和 static_assert]]中讨论如何做到这一点。

## `sizeof` 运算符

为了确定特定机器上数据类型的大小，C++ 提供了一个名为 `sizeof` 的运算符。`sizeof` 是一个一元运算符，它接受类型或变量，返回其大小（以字节为单位）。你可以编译并运行以下程序，来查看某些数据类型的大小：

```cpp
#include <iomanip> // 为了使用 std::setw (设置后续输出的宽度)
#include <iostream>

int main()
{
    std::cout << std::left; // 输出左对齐
    std::cout << std::setw(16) << "bool:" << sizeof(bool) << " bytes\n";
    std::cout << std::setw(16) << "char:" << sizeof(char) << " bytes\n";
    std::cout << std::setw(16) << "short:" << sizeof(short) << " bytes\n";
    std::cout << std::setw(16) << "int:" << sizeof(int) << " bytes\n";
    std::cout << std::setw(16) << "long:" << sizeof(long) << " bytes\n";
    std::cout << std::setw(16) << "long long:" << sizeof(long long) << " bytes\n";
    std::cout << std::setw(16) << "float:" << sizeof(float) << " bytes\n";
    std::cout << std::setw(16) << "double:" << sizeof(double) << " bytes\n";
    std::cout << std::setw(16) << "long double:" << sizeof(long double) << " bytes\n";

    return 0;
}
```

以下是作者机器上的输出：

```plaintext
bool:           1 bytes
char:           1 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    8 bytes
```

你的结果可能会根据编译器、计算机架构、操作系统、编译设置（32 位 vs 64位）等有所不同……

尝试对不完整类型（如 `void`）使用 `sizeof` 会导致编译错误。

你也可以在变量名上使用 `sizeof` 运算符：

```cpp
#include <iostream>

int main()
{
    int x{};
    std::cout << "x 的大小是 " << sizeof(x) << " 字节\n";

    return 0;
}
```

输出结果：

```plaintext
x 的大小是 4 字节
```

> **面向高级读者**
> 
> `sizeof` 不包括对象使用的动态分配内存。我们将在后续课程中讨论**动态内存分配**。

## 基本数据类型的性能

在现代机器上，**基本数据类型**的对象性能非常快，因此使用或复制这些类型的性能通常不必担心。

> **顺便一提……**
> 
> 你可能会认为使用较少内存的类型比使用更多内存的类型更快。这并不总是正确的。CPU 通常针对特定大小的数据进行了优化处理（例如 32 位），而与此大小匹配的类型可能会被更快处理。在这种机器上，**32 位 `int`** 可能比 **16 位 `short`** 或 **8 位 `char`** 更快。

# 4.4 Signed integer 有符号整数
**整数**（**integer**）指的是整型类型，可以表示正数、负数和 0（例如 -2、-1、0、1、2）。C++ 提供了 4 种主要的基本整数类型：

| 类型              | 最小大小      | 备注                                             |
|-------------------|---------------|-------------------------------------------------|
| `short int`       | 16 位         |                                                 |
| `int`             | 16 位         | 现代架构中通常为 32 位                           |
| `long int`        | 32 位         |                                                 |
| `long long int`   | 64 位         |                                                 |

这些整数类型的主要区别在于它们的大小不同——较大的整数类型可以表示更大的数字。

> [!info] 提醒
>
> C++ 只保证整数类型具有一定的最小大小，并不保证它们具有特定的大小。有关如何确定每种类型在你的计算机上占用多少空间的信息，请参阅 [[Chapter 4 - Fundamental Data Types#4.3 Object sizes and the `sizeof` operator|4.3 — 对象大小与 `sizeof` 运算符]]。

> [!info] 顺便一提……
> 
> 从技术上讲，`bool` 和 `char` 类型也被认为是整型类型（因为这些类型将其值存储为整数值）。在接下来的几节中，我们将排除这些类型的讨论。

## 有符号整数
在日常生活中，写负数时我们使用负号。例如，`-3` 表示“负 3”。我们也通常会将 `+3` 识别为“正 3”（尽管常规约定中我们通常省略正号）。

数字的**正负性**（**sign**）表示其是正数、负数还是 0。

在 C++ 中，**默认情况下，整数是有符号的**，这意味着数字的正负号作为值的一部分存储。因此，有符号整数可以表示正数、负数和 0。

在本节中，我们将重点讨论**有符号整数**。我们将在下一节讨论只能表示非负数的**无符号整数**。
## 定义有符号整数
以下是定义四种有符号整数类型的首选方式：

```cpp
short s;      // 推荐使用 "short" 而不是 "short int"
int i;
long l;       // 推荐使用 "long" 而不是 "long int"
long long ll; // 推荐使用 "long long" 而不是 "long long int"
```

尽管 `short int`、`long int` 或 `long long int` 也是有效的写法，但我们更推荐使用这些类型的短写形式（不带 `int` 后缀）。添加 `int` 后缀不仅增加了书写量，还可能导致类型与 `int` 类型混淆。如果不小心忽略了 `short` 或 `long` 修饰符，容易出错。

这些整数类型也可以加上可选的 `signed` 关键字，按约定通常放在类型名称之前：

```cpp
signed short ss;
signed int si;
signed long sl;
signed long long sll;
```

然而，不应使用这个关键字，因为它是多余的，**整数默认是有符号的**。

> [!tip] 最佳实践
> 
> 推荐使用不带 `int` 后缀或 `signed` 前缀的简短类型。
## 有符号整数的范围
如你在上一节中所学，一个 `n` 位的变量可以表示 **2^n** 个可能的值。那么这些值具体是什么呢？我们称一个数据类型可以表示的特定值的集合为**范围**（**range**）。整数变量的范围由两个因素决定：其大小（以位为单位）以及它是否有符号。

定义上，**8 位有符号整数**的范围是 `-128` 到 `127`。这意味着有符号整数可以安全地存储介于 `-128` 到 `127` 之间的任何整数值。

> [!info] 顺便一提……
> 
> 数学时间：一个 8 位整数包含 8 位。2^8 是 256，因此一个 8 位整数可以表示 256 个可能的值。在 `-128` 到 `127` 之间正好有 256 个值。
> 
> 7 位用于表示数字的大小，1 位用于表示符号。

以下是不同大小的有符号整数的范围表：

| 大小/类型      | 范围                                          |
|----------------|-----------------------------------------------|
| 8 位有符号     | `-128` 到 `127`                               |
| 16 位有符号    | `-32,768` 到 `32,767`                         |
| 32 位有符号    | `-2,147,483,648` 到 `2,147,483,647`           |
| 64 位有符号    | `-9,223,372,036,854,775,808` 到 `9,223,372,036,854,775,807` |

对于擅长数学的人来说，一个 `n` 位有符号变量的范围是 `-(2^(n-1))` 到 `2^(n-1)-1`。

对于不擅长数学的人……使用上面的表格即可。 :)
## 溢出
如果我们尝试将值 `140` 赋给一个 8 位有符号整数会发生什么？这个数值超出了 8 位有符号整数可以表示的范围。表示 `140` 需要 9 位（8 位大小 + 1 位符号位），但我们只有 8 位（7 位大小 + 1 位符号位）可用。

C++20 标准做出了如下声明：“如果在表达式的求值过程中，结果超出了该类型的可表示值的范围，行为是未定义的”。一般我们把这种情况叫做**溢出**。

因此，将值 `140` 赋给 8 位有符号整数将导致**未定义行为**。

如果算术操作（如加法或乘法）尝试生成超出可表示范围的值，这称为**整数溢出**（或**算术溢出**）。对于有符号整数，整数溢出将导致**未定义行为**。

```cpp
#include <iostream>

int main()
{
    // 假设是 4 字节整数
    int x { 2'147'483'647 }; // 4 字节有符号整数的最大值
    std::cout << x << '\n';

    x = x + 1; // 整数溢出，未定义行为
    std::cout << x << '\n';

    return 0;
}
```

在作者的机器上，上面的代码输出如下：

```plaintext
2147483647
-2147483648
```

然而，由于第二次输出是未定义行为的结果，输出的值可能会因机器而异。

 
> [!info] 面向高级读者
> 
> 我们将在[[Chapter 4 - Fundamental Data Types#4.5 Unsigned integers, and why to avoid them|4.5 — 无符号整数]]中讨论无符号整数溢出时会发生什么，以及为什么应该避免这种情况。

一般来说，溢出会导致信息丢失，这几乎从来不是我们想要的。如果怀疑某个对象可能需要存储超出其范围的值，请使用一个范围更大的类型！
## 整数除法
当两个整数相除时，如果商是整数，C++ 会按预期工作：

```cpp
#include <iostream>

int main()
{
    std::cout << 20 / 4 << '\n';
    return 0;
}
```

这会产生预期的结果：

```plaintext
5
```

但让我们看看当整数除法导致小数结果时会发生什么：

```cpp
#include <iostream>

int main()
{
    std::cout << 8 / 5 << '\n';
    return 0;
}
```

这会产生一个可能出乎意料的结果：

```plaintext
1
```

当两个整数相除时（称为**整数除法**），C++ 始终会生成一个整数结果。由于整数不能表示小数部分，任何小数部分都将被**舍弃**（而不是四舍五入！）。

再详细看看上面的例子，`8 / 5` 结果为 `1.6`。小数部分 `0.6` 被舍弃，剩下的结果是 `1`。或者我们可以说 `8 / 5` 等于 `1` 余 `3`。余数被舍弃，留下 `1`。

同样，`-8 / 5` 结果为 `-1`。

> [!danger] 警告
> 
> 使用**整数除法**时要小心，因为你将丢失商的小数部分。然而，如果这是你想要的，整数除法是安全的，因为结果是可预测的。

如果需要小数结果，我们将在[[Chapter 6 - Operators#6.2 Arithmetic operators|6.2 — 算术运算符]]中介绍如何实现这一点。
## 测试时间

> [!question]- 问题 1: 一个 5 位有符号整数的范围是多少？
> 一个 5 位数可以支持 **2^5 = 32** 个唯一值。对于有符号整数，这些值几乎均匀地分布在正数和负数之间，负数侧会多一个值。因此范围是 `-16` 到 `15`。
> 
> 另一种思考方式：5 位中的 1 位用于表示符号。剩下 4 位用于表示数值大小。4 位可以表示 16 个唯一值。在负数侧，这些数值位代表从 `-1` 到 `-16` 的值。在非负数侧，这些数值位代表从 `0` 到 `15` 的值。因为 `0` 包含在非负数侧，所以非负数范围少一个值。

> [!question]- 问题 2(a): `13 / 5` 的结果是多少？
> `13 / 5 = 2` 余 `3`。余数被舍弃，留下 `2`。

> [!question]- 问题 2(b): `-13 / 5` 的结果是多少？
> `-13 / 5 = -2` 余 `-3`。余数被舍弃，留下 `-2`。

# 4.5 Unsigned integers, and why to avoid them
## 无符号整数
在上一节 [[#4.4 Signed integer 有符号整数]] 中，我们讨论了有符号整数，它们是一组可以表示正数、负数和 0 的类型。

C++ 还支持**无符号整数**。无符号整数是只能表示非负整数的类型。
## 定义无符号整数
定义无符号整数时，我们使用 `unsigned` 关键字。按约定，`unsigned` 关键字放在类型名称之前：

```cpp
unsigned short us;
unsigned int ui;
unsigned long ul;
unsigned long long ull;
```
## 无符号整数的范围
一个 1 字节的无符号整数的范围是 `0` 到 `255`。与 1 字节有符号整数的范围 `-128` 到 `127` 相比，两者都可以存储 256 个不同的值，但有符号整数使用一半的范围表示负数，而无符号整数可以存储大得多的正数。

以下是无符号整数的范围表：

| 大小/类型         | 范围                         |
|-------------------|------------------------------|
| 8 位无符号整数    | `0` 到 `255`                 |
| 16 位无符号整数   | `0` 到 `65,535`              |
| 32 位无符号整数   | `0` 到 `4,294,967,295`       |
| 64 位无符号整数   | `0` 到 `18,446,744,073,709,551,615` |

一个 `n` 位无符号变量的范围是 `0` 到 `(2^n) - 1`。

当不需要负数时，无符号整数非常适合网络和内存较小的系统，因为无符号整数可以在不增加额外内存的情况下存储更多的正数。
## 记住有符号和无符号
新手程序员有时会混淆**有符号**和**无符号**。以下是一个简单的记忆方式：为了区分负数和正数，我们使用负号。如果没有提供符号，我们假设数是正数。因此，一个带符号的整数（有符号整数）可以区分正数和负数。一个不带符号的整数（无符号整数）假设所有值都是正数。
## 无符号整数溢出
如果我们尝试将 `280`（需要 9 位来表示）存储在一个 1 字节（8 位）的无符号整数中，会发生什么？答案是**溢出**。

> [!info] 作者说明
> 
> 奇怪的是，C++ 标准明确表示：“涉及无符号操作数的计算永远不会溢出”。这与一般的编程共识相反，后者认为整数溢出包含有符号和无符号情况。鉴于大多数程序员会将这种情况视为溢出，我们在此将其称为溢出，尽管 C++ 标准的说法相反。

如果无符号值超出范围，则它会除以该类型最大值的加 1，保留余数。

数值 `280` 超出了 1 字节范围的 `0` 到 `255`。该类型最大值的加 1 是 `256`。因此，我们将 `280` 除以 `256`，得到余数 `24`，存储的就是 `24`。

换句话说，任何大于类型最大可表示数的数值都会**回绕**（有时称为“取模回绕”）。`255` 在 1 字节整数的范围内，所以 `255` 是有效的。但 `256` 超出范围，因此它回绕到值 `0`。`257` 回绕到值 `1`。`280` 回绕到值 `24`。

我们用 2 字节的 `short` 来演示一下：

```cpp
#include <iostream>

int main()
{
    unsigned short x{ 65535 }; // 最大的 16 位无符号值
    std::cout << "x 的初始值: " << x << '\n';

    x = 65536; // 65536 超出范围，发生回绕
    std::cout << "x 现在的值: " << x << '\n';

    x = 65537; // 65537 超出范围，发生回绕
    std::cout << "x 现在的值: " << x << '\n';

    return 0;
}
```

你认为这个程序的结果会是什么？

> [!note] 注意：
> 
> 如果你尝试编译上述程序，编译器应该会发出有关溢出或截断的警告——你需要禁用“将警告视为错误”才能运行该程序）

```plaintext
x 的初始值: 65535
x 现在的值: 0
x 现在的值: 1
```

也可以向另一个方向回绕。`0` 在 2 字节无符号整数中是可表示的，因此这是有效的。`-1` 不可表示，因此它回绕到范围的顶部，得到值 `65535`。`-2` 回绕到 `65534`，依此类推。

```cpp
#include <iostream>

int main()
{
    unsigned short x{ 0 }; // 最小的 2 字节无符号值
    std::cout << "x 的初始值: " << x << '\n';

    x = -1; // -1 超出范围，发生回绕
    std::cout << "x 现在的值: " << x << '\n';

    x = -2; // -2 超出范围，发生回绕
    std::cout << "x 现在的值: " << x << '\n';

    return 0;
}
```

输出结果：

```plaintext
x 的初始值: 0
x 现在的值: 65535
x 现在的值: 65534
```

以上代码在某些编译器中会触发警告，因为编译器检测到整数字面量超出了给定类型的范围。如果你想继续编译代码，请临时禁用“将警告视为错误”。

> [!info] 顺便一提……
> 
> 许多著名的游戏历史错误都是由于无符号整数的回绕行为造成的。在经典的街机游戏《Donkey Kong》中，由于溢出错误，玩家无法超过 22 关，这会导致玩家没有足够的奖励时间完成关卡。
> 
> 在 PC 游戏《文明》中，甘地以首先使用核武器而闻名，这似乎与他预期的和平性格相反。玩家曾推测，甘地的攻击性最初设定为 `1`，但如果他选择了民主政府，他会获得 `-2` 的攻击性修正（将当前攻击性值降低 2）。这会导致攻击性溢出到 `255`，使他变得极其好战！然而，游戏作者 Sid Meier 最近澄清这并不属实。

## 关于无符号数的争议
许多开发者（以及一些大型开发公司，如 Google）认为开发者应该尽量避免使用无符号整数。

这主要是因为两种行为可能会导致问题：

首先，对于有符号值，想要意外溢出范围的上限或下限需要一些努力，因为这些值距离 `0` 很远。而对于无符号数，溢出下限则容易得多，因为下限是 `0`，这离大多数值的位置很近。

考虑两个无符号数的减法，例如 `2` 和 `3`：

```cpp
#include <iostream>

int main()
{
    unsigned int x{ 2 };
    unsigned int y{ 3 };

    std::cout << x - y << '\n'; // 输出 4294967295（错误！）

    return 0;
}
```

你我都知道 `2 - 3` 是 `-1`，但 `-1` 不能表示为无符号整数，因此会发生溢出，结果是：

```plaintext
4294967295
```

另一个常见的意外回绕是当一个无符号整数被重复递减到试图变成负数时。你将在循环介绍中看到这个例子。

其次，更隐蔽的是，当你混合使用有符号和无符号整数时可能会导致意外行为。在 C++ 中，如果一个数学运算（例如算术或比较）有一个有符号整数和一个无符号整数，通常有符号整数会被转换为无符号整数，结果也将是无符号的。例如：

```cpp
#include <iostream>

int main()
{
    unsigned int u{ 2 };
    signed int s{ 3 };

    std::cout << u - s << '\n'; // 2 - 3 = 4294967295

    return 0;
}
```

这会产生如下结果：

```plaintext
4294967295
```

在这种情况下，如果 `u` 是有符号的，将会产生正确结果。但因为 `u` 是无符号的（这很容易被忽略），`s` 被转换为无符号，结果 `-1` 被视为无符号值。由于 `-1` 无法存储在无符号值中，因此会发生溢出并得到意外结果。

这里有另一个出错的例子：

```cpp
#include <iostream>

int main()
{
    signed int s { -1 };
    unsigned int u { 1 };

    if (s < u) // -1 被隐式转换为 4294967295，而 4294967295 < 1 是错误的
        std::cout << "-1 小于 1\n";
    else
        std::cout << "1 小于 -1\n"; // 这个语句被执行

    return 0;
}
```

输出结果：

```plaintext
1 小于 -1
```

这个程序语法正确，编译成功，并且逻辑上看起来也是一致的。但它输出了错误的结果。尽管编译器应该警告你有符号/无符号不匹配，但它也会对其他没有问题的情况（例如两个数都是正数时）发出相同的警告，这使得检测实际问题变得困难。

> [!info] 相关内容
> 
 > 我们将在[[Chapter 10 - Type Conversion, Type Aliases, and Type Deduction#10.5 Arithmetic conversions|10.5 — 算术转换]]中讨论要求二元运算的操作数必须是相同类型的转换规则。我们将在后续的 [[Chapter 4 - Fundamental Data Types#4.10 Introduction to `if` statements|4.10 — if 语句介绍]] 中讨论 `if` 语句。

此外，还有一些其他问题很难检测。例如：

```cpp
#include <iostream>

void doSomething(unsigned int x)
{
    std::cout << "x 是 " << x << '\n';
}

int main()
{
    doSomething(-1);

    return 0;
}
```

`doSomething()` 的作者期望有人调用此函数时只传入正数。但调用者传入了 `-1`——显然这是个错误，但仍然发生了。那么在这种情况下会发生什么？

带符号的参数 `-1` 被隐式转换为无符号参数。`-1` 超出了无符号数的范围，因此回绕到 `4294967295`。然后程序可能会出现不可预期的行为。

更麻烦的是，防止这种情况发生很困难。除非你已经配置编译器生成有关有符号/无符号转换的警告（你应该这样做），否则编译器可能根本不会抱怨这一点。

所有这些问题都经常遇到，产生意外行为，并且即使使用旨在检测问题的自动化工具也很难找到。

鉴于上述原因，我们主张的略显有争议的最佳实践是：**除特定情况外，避免使用无符号类型**。

> [!tip] 最佳实践
> 
> 对于表示数量（即使数量应该是非负的）和进行数学运算时，**优先使用有符号数而不是无符号数**。避免混用有符号数和无符号数。

> [!info] 相关内容
> 
> 以下是支持上述建议的附加材料（还涵盖了针对一些常见反驳的反驳）：
> 
> - [Interactive C++ Panel](https://www.youtube.com/watch?v=_nrly6PH6NU)
> - [Bjarne Stroustrup（C++ 之父）的文章](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf)——下标和大小应该使用有符号数
> - [libtorrent 博客上的无符号整数问题](https://blog.libtorrent.org/2016/05/unsigned-integers/)

## 什么时候使用无符号数？
在 C++ 中，仍然有一些情况是可以或必须使用无符号数的。

首先，当处理位操作时（见[[Chapter O - Bit Manipulation|第O章]]——注意这是大写字母 'O'，不是数字 '0'），优先使用无符号数。当需要**明确定义的回绕行为**时（在某些算法如加密和随机数生成中有用），无符号数也是有用的。

其次，在某些情况下使用无符号数是不可避免的，主要是在涉及**数组索引**时。我们将在数组和数组索引的课程中详细讨论这一点。

还需要注意的是，如果你在为嵌入式系统（如 Arduino）或其他处理器/内存受限的环境中开发，出于性能原因，使用无符号数更为常见且被接受（在某些情况下是不可避免的）。
# 4.6 Fixed-width integers and `size_t

### 4.6 — 定宽整数和 `size_t`
**Alex**  
**2024年8月19日**

在之前的整数相关课程中，我们讨论了 C++ 只保证整数变量的最小大小——但它们的实际大小可能更大，具体取决于目标系统。

#### 为什么整数变量的大小不是固定的？

简短的回答是，这可以追溯到 C 语言的早期，当时计算机运行速度较慢，性能至关重要。C 选择有意让整数的大小保持开放，以便编译器实现者可以为 `int` 选择在目标计算机体系结构上性能最佳的大小。

#### 这不让人很烦吗？

以现代标准来看，确实是有点烦。作为程序员，我们不得不处理具有不确定范围的类型，这有点荒谬。

考虑 `int` 类型。`int` 的最小大小是 2 字节，但在现代体系结构上，它通常是 4 字节。

如果你假设 `int` 是 4 字节，因为这很有可能，那么你的程序在 `int` 实际上是 2 字节的体系结构上可能会表现异常（因为你可能会在 2 字节变量中存储需要 4 字节的数据，这会导致溢出或未定义行为）。

如果你假设 `int` 只有 2 字节以确保最大兼容性，那么你可以安全存储在 `int` 中的值范围将会受到很大限制。而在 `int` 实际上是 4 字节的系统上，你没有充分利用每个 `int` 变量分配的内存。

#### 定宽整数

为了解决上述问题，C99 定义了一组定宽整数（在 `<stdint.h>` 头文件中），这些整数在任何体系结构上都保证是相同的大小。

它们定义如下：

| 名称            | 类型       | 范围                                            | 备注                                                   |
|-----------------|------------|-------------------------------------------------|--------------------------------------------------------|
| `std::int8_t`   | 1 字节有符号 | -128 到 127                                    | 在许多系统上被视为 `signed char`。请参见下文说明。       |
| `std::uint8_t`  | 1 字节无符号 | 0 到 255                                       | 在许多系统上被视为 `unsigned char`。                     |
| `std::int16_t`  | 2 字节有符号 | -32,768 到 32,767                              |                                                        |
| `std::uint16_t` | 2 字节无符号 | 0 到 65,535                                    |                                                        |
| `std::int32_t`  | 4 字节有符号 | -2,147,483,648 到 2,147,483,647                |                                                        |
| `std::uint32_t` | 4 字节无符号 | 0 到 4,294,967,295                             |                                                        |
| `std::int64_t`  | 8 字节有符号 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 |                                                        |
| `std::uint64_t` | 8 字节无符号 | 0 到 18,446,744,073,709,551,615                |                                                        |

C++ 在 C++11 中正式采用了这些定宽整数。可以通过包含 `<cstdint>` 头文件来访问它们，它们定义在 `std` 命名空间中。示例如下：

```cpp
#include <cstdint> // 用于定宽整数
#include <iostream>

int main()
{
    std::int16_t i{5};
    std::cout << i << '\n';
    return 0;
}
```

尽管定宽整数解决了许多问题，但它们也有两个常见的缺点：

1. **定宽整数并不能保证在所有体系结构上都定义。**它们只存在于符合其宽度且遵循特定二进制表示法的系统上。如果你的程序使用的某个定宽整数在目标体系结构上未定义，那么程序将无法编译。然而，考虑到大多数现代体系结构已经标准化为 8/16/32/64 位变量，除非你的程序需要移植到一些特殊的大型机或嵌入式体系结构上，否则这不太可能成为问题。

2. **在某些体系结构上，使用定宽整数可能比使用更宽的类型速度慢。**例如，如果你需要一个保证是 32 位的整数，你可能会选择 `std::int32_t`，但你的 CPU 实际上可能在处理 64 位整数时更快。然而，现代程序往往受到内存使用的限制，而不是 CPU 的限制，较大的内存占用可能会比更快的 CPU 处理拖慢程序速度。是否真的更快，需要通过实际测量来判断。

#### 快速和最小整数类型

为了帮助解决上述缺点，C++ 还定义了两组替代的整数类型，它们在所有体系结构上都保证定义。

- **快速类型（`std::int_fast#_t` 和 `std::uint_fast#_t`）** 提供了具有至少 # 位宽度的最快的有符号/无符号整数类型（其中 # = 8, 16, 32 或 64）。
- **最小类型（`std::int_least#_t` 和 `std::uint_least#_t`）** 提供了具有至少 # 位宽度的最小的有符号/无符号整数类型。

#### `size_t` 是什么？

`std::size_t` 是一种实现定义的无符号整数类型，通常用于表示对象的大小或长度。

```cpp
#include <cstddef> // 用于 std::size_t
#include <iostream>

int main()
{
    int x { 5 };
    std::size_t s { sizeof(x) }; // sizeof 返回一个 std::size_t 类型的值
    std::cout << s << '\n';

    return 0;
}
```

#### 最佳实践

- **当整数大小无关紧要时**，优先使用 `int`。  
- **当需要保证范围时**，使用 `std::int#_t`。  
- **进行位操作或需要定义明确的溢出行为时**，使用 `std::uint#_t`。

避免以下类型：
- `short` 和 `long` 整数——请使用定宽类型。
- 用于存储数量的无符号类型。
- 8 位定宽整数类型。`
### 4.6 — 定宽整数和 `size_t` (继续)

#### `std::size_t` 的使用场景

`std::size_t` 在 C++ 标准库中被广泛用于表示对象的字节大小、数组的长度以及指针差值等情况。由于 `std::size_t` 是无符号整数类型，它可以保证不会出现负数，这在需要处理对象大小、内存分配或数组索引等任务时是理想的。

例如，在数组中经常会看到以下用法：

```cpp
#include <iostream>

int main()
{
    int array[5] = {1, 2, 3, 4, 5};
    for (std::size_t i = 0; i < sizeof(array) / sizeof(array[0]); ++i)
    {
        std::cout << array[i] << ' ';
    }
    std::cout << '\n';

    return 0;
}
```

在上面的代码中，`sizeof` 操作符返回数组的大小（以字节为单位），而每个元素的大小是 `sizeof(array[0])`。通过将这两个值相除，可以确定数组中的元素个数。由于 `sizeof` 返回 `std::size_t` 类型的值，因此循环变量 `i` 也应使用 `std::size_t` 类型来匹配。

#### 为什么要使用 `std::size_t`

在程序中使用 `std::size_t` 作为数组索引或处理内存大小的类型具有以下优势：

1. **避免负值问题**：由于 `std::size_t` 是无符号的，它可以确保你不会意外地引入负值，特别是在处理数组索引时。这可以防止在数组操作中出现意外行为。
2. **跨平台兼容性**：`std::size_t` 的大小与系统架构相关，通常与处理器的地址空间相对应。在 32 位系统上，它通常是 32 位，而在 64 位系统上，它通常是 64 位。这意味着它可以有效地表示大多数情况下的内存大小和数组索引。
3. **标准库的推荐类型**：在 C++ 标准库中，大多数关于内存大小、数组索引的函数都返回 `std::size_t`，例如 `sizeof` 操作符和标准库的容器大小函数（如 `std::vector::size()`）。因此，使用 `std::size_t` 可以保证类型一致性，减少不必要的类型转换。

#### 总结

- **定宽整数**：对于需要明确大小的整数类型，推荐使用定宽整数类型（如 `std::int32_t`、`std::uint64_t`）。它们可以保证在不同的架构上具有相同的大小。
- **快速和最小整数类型**：在某些情况下，使用快速或最小整数类型（如 `std::int_fast32_t`）可以提升性能或减少内存使用，但要注意可能带来的不一致行为。
- **`std::size_t`**：在涉及数组大小、内存大小等场景时，建议使用 `std::size_t` 来处理大小和索引。它能确保无符号值，并且在不同架构上具有灵活性。

最重要的还是要根据应用场景合理选择数据类型，以确保代码的可维护性、可移植性和性能。

# 4.7 Introduction to scientific notation

### 4.7 — 科学记数法简介

在我们讨论下一个主题之前，我们将稍作旁白，介绍一下**科学记数法**。

科学记数法是一种简洁表示长数字的有效方法。尽管一开始科学记数法看起来有些陌生，但理解科学记数法将有助于理解浮点数的工作原理，更重要的是，帮助你了解其局限性。

科学记数法的数字形式如下：**有效数字 × 10 的指数次方**。例如，在科学记数法 `1.2 × 10⁴` 中，`1.2` 是有效数字，`4` 是指数。由于 `10⁴` 等于 `10,000`，因此 `1.2 × 10⁴` 等于 `12,000`。

按惯例，科学记数法中的数字在小数点前通常只有一位数字，其他位数在小数点之后。

例如，地球的质量用十进制表示为 `5972200000000000000000000` 千克。这是一个非常大的数字（甚至无法放进一个 8 字节的整数中）。而且，它也很难阅读（到底是 19 个还是 20 个零呢？）。即使有分隔符（如 `5,972,200,000,000,000,000,000,000`），这个数字仍然不容易读。

用科学记数法，这个数字可以表示为 `5.9722 × 10²⁴` 千克，这样更易于阅读。科学记数法还有一个好处是，可以通过比较指数的大小，轻松比较两个极大或极小数字的数量级。

由于在 C++ 中键入或显示指数可能会有些困难，我们使用字母 `e`（有时是 `E`）来表示“乘以 10 的几次方”的部分。例如，`1.2 × 10⁴` 可以写成 `1.2e4`，而 `5.9722 × 10²⁴` 则可以写成 `5.9722e24`。

对于小于 1 的数字，指数可以为负数。数字 `5e-2` 等价于 `5 * 10⁻²`，即 `5 / 10²`，或者 `0.05`。电子的质量为 `9.1093837e-31` 千克。

#### 有效数字

假设你需要知道数学常数 π 的值用于某个公式，但你忘记了。你向两个人询问，一个人告诉你 π 的值是 `3.14`，另一个人告诉你是 `3.14159`。这两个值都是“正确的”，但后者明显更精确。

关于科学记数法，最重要的是理解有效数字（位于 `e` 之前的部分）越多，数字越精确。

**关键见解**  
有效数字越多，数字越精确。

在科学记数法中，我们可以写作 `3.14` 为 `3.14e0`。由于有效数字部分有 3 位数字，所以该数字有 3 个有效数字。

而 `3.14159` 则写作 `3.14159e0`，其有效数字有 6 位数字，因此该数字有 6 个有效数字。

#### 如何将十进制数转换为科学记数法

转换为科学记数法的步骤如下：

1. 指数初始为零。
2. 移动小数点，使得小数点左边只有一位非零数字。
3. 每向左移动一位小数点，指数增加 1。
4. 每向右移动一位小数点，指数减少 1。
5. 去除有效数字前的任何零（如果有）。
6. 如果原始数字没有小数点，则去除有效数字末尾的任何零。如果有其他信息表明这些零是有效的，则保留它们。

以下是一些示例：

- 开始：600.410  
  向左移动小数点 2 位：6.00410e2  
  没有前导零：6.00410e2  
  不去除尾部零：6.00410e2（6 个有效数字）

- 开始：0.0078900  
  向右移动小数点 3 位：0007.8900e-3  
  去除前导零：7.8900e-3  
  不去除尾部零：7.8900e-3（5 个有效数字）

- 开始：42030（没有信息表明尾部零是有效的）  
  向左移动小数点 4 位：4.2030e4  
  没有前导零：4.2030e4  
  去除尾部零：4.203e4（4 个有效数字）

#### 处理尾部零

考虑这样一种情况，我们让两个实验助手分别称量同一个苹果。一个助手返回的结果是苹果重 `87.0` 克，另一个助手返回的结果是 `87.000` 克。假设称重结果是准确的。在第一种情况下，苹果的实际重量可能在 `86.950` 和 `87.049` 克之间，可能是因为称量精度只能精确到小数点后一位，或者助手稍微进行了四舍五入。在第二种情况下，我们对苹果的实际重量更加有信心，它的重量在 `86.99950` 和 `87.00049` 克之间，变化幅度要小得多。

转换为科学记数法时，小数点后的尾部零被认为是有效的，因此我们保留它们：

- `87.0` 克 = `8.70e1`  
- `87.000` 克 = `8.7000e1`

对于没有小数点的数字，尾部零通常被认为是无效的。例如数字 `2100`（没有额外信息），我们假设尾部的 0 无效，因此去除它们：

- `2100` = `2.1e3`（尾部零假设无效）

然而，如果我们知道该数字是精确测量的（或者实际值在 `2099.5` 到 `2100.5` 之间），那么我们应该将这些零视为有效的：

- `2100` = `2.100e3`（尾部零已知有效）

#### 科学记数法练习

**问题 1**  
将以下数字转换为科学记数法（使用 `e` 表示指数），并确定每个数字的有效位数。

a) 34.50  
**答案**：`3.450e1`（4 个有效数字）

b) 0.004000  
**答案**：`4.000e-3`（4 个有效数字）

c) 123.005  
**答案**：`1.23005e2`（6 个有效数字）

d) 146000  
**答案**：`1.46e5`（3 个有效数字，假设尾部零无效）

e) 146000.001  
**答案**：`1.46000001e5`（9 个有效数字）

f) 0.0000000008  
**答案**：`8e-10`（1 个有效数字）

g) 34500.0  
**答案**：`3.45000e4`（6 个有效数字）

h) 146000（假设你知道尾部零有效）  
**答案**：`1.46000e5`（6 个有效数字）

# 4.8 Floating point numbers 浮点数
整数适用于存储整数，但有时我们需要存储非常大的（正或负）数字，或带有小数部分的数字。**浮点类型变量**是一种可以存储带有小数部分的数字的变量，例如 `4320.0`，`-3.33`，或 `0.01226`。术语“浮点”指的是小数点可以“浮动”——也就是说，它可以支持在小数点前后使用可变数量的数字。

> [!tip] **提示** 
> 
> 编写浮点数时，小数分隔符必须是小数点。如果你来自一个使用逗号作为小数分隔符的国家，那么你需要习惯使用小数点。

C++ 中有三种标准的浮点数据类型：**单精度浮点数** `float`，**双精度浮点数** `double`，以及**扩展精度浮点数** `long double`。与整数类似，C++ 并未定义这些类型的实际大小。

浮点数据类型总是有符号的（可以存储正数和负数）。

| 类别        | 类型        | 典型大小      |
|-------------|-------------|---------------|
| 浮点数      | float       | 4 字节         |
| 双精度浮点数 | double      | 8 字节         |
| 扩展精度浮点数 | long double | 8、12 或 16 字节 |

在现代架构中，`float` 和 `double` 的浮点数表示几乎总是遵循 **IEEE 754 二进制格式**（由 [William Kahan](https://en.wikipedia.org/wiki/William_Kahan) 创建）。在此格式中，`float` 是 4 字节，`double` 是 8 字节。

`long double` 有些特殊。根据实现的不同，它可能等同于一个 8 字节的 `double`，也可能是一个 16 字节的 IEEE 754 格式值，或者是一个 80 位（通常填充到 12 字节）的非 IEEE 754 格式值。建议避免使用 `long double`。

> [!note] **作者注**
>
> 这些浮点数相关的课程假设你的编译器正在使用 IEEE 754 格式来表示 `float` 和 `double`。

> [!info] **对于高级读者**  
> 您可以通过以下代码查看您的浮点类型是否使用 IEEE 754 格式：
> 

 ```cpp
 #include <iostream>
 #include <limits> // 需要包含此头文件以使用 numeric_limits
 
 int main()
 {
     std::cout << std::numeric_limits<float>::is_iec559 << '\n';
     std::cout << std::numeric_limits<double>::is_iec559 << '\n';
     std::cout << std::numeric_limits<long double>::is_iec559 << '\n';
 }
 ```




#### 浮点变量的定义

```cpp
float fValue;
double dValue;
long double ldValue;
```

编写浮点字面值时，始终至少包括一个小数位（即使小数为 0）。这有助于编译器理解这是一个浮点数，而不是整数。

```cpp
int a { 5 };      // 5 表示整数
double b { 5.0 }; // 5.0 是浮点字面值（无后缀表示默认的 double 类型）
float c { 5.0f }; // 5.0 是浮点字面值，f 后缀表示 float 类型

int d { 0 }       // 0 是整数
double e { 0.0 }  // 0.0 是 double 类型
```

需要注意的是，默认情况下，浮点字面值默认为 `double` 类型。`f` 后缀用于表示 `float` 类型的字面值。

**最佳实践**  
确保字面值的类型与其被分配或初始化的变量类型匹配，否则可能会产生不必要的转换，并可能导致精度损失。

#### 浮点数的范围

假设使用 IEEE 754 表示法，浮点数的范围和精度如下：

| 大小         | 范围                                        | 精度                                   |
|--------------|---------------------------------------------|----------------------------------------|
| 4 字节       | ±1.18 x 10⁻³⁸ 到 ±3.4 x 10³⁸ 以及 0.0       | 6-9 个有效数字，通常为 7               |
| 8 字节       | ±2.23 x 10⁻³⁰⁸ 到 ±1.80 x 10³⁰⁸ 以及 0.0    | 15-18 个有效数字，通常为 16            |
| 80 位        | ±3.36 x 10⁻⁴⁹³² 到 ±1.18 x 10⁴⁹³² 以及 0.0  | 18-21 个有效数字                       |
| 16 字节      | ±3.36 x 10⁻⁴⁹³² 到 ±1.18 x 10⁴⁹³² 以及 0.0  | 33-36 个有效数字                       |

#### 浮点数的精度

考虑分数 `1/3`。其小数表示为 `0.33333333333333...`，后面的 3 无限延伸。如果你在纸上写这个数字，你的手会累，最终你会停下来。而你写下的数字将接近 `0.3333333333...`，但并不完全等同。

在计算机中，无限精度的数字将需要无限的内存来存储，但我们通常只能为每个值分配 4 或 8 字节。这意味着浮点数只能存储一定数量的有效数字，额外的有效数字要么丢失，要么被不精确地表示。实际上存储的数字可能接近所需的数字，但并不完全相同。

浮点数类型的**精度**定义了它能在不丢失信息的情况下表示的有效数字数量。

#### 打印浮点数

```cpp
#include <iostream>

int main()
{
    std::cout << 9.87654321f << '\n';
    std::cout << 987.654321f << '\n';
    std::cout << 987654.321f << '\n';
    std::cout << 9876543.21f << '\n';
    std::cout << 0.0000987654321f << '\n';

    return 0;
}
```

输出结果：

```
9.87654
987.654
987654
9.87654e+006
9.87654e-005
```

你可以使用 `std::setprecision()` 来改变默认的 6 位输出精度。例如：

```cpp
#include <iomanip>
#include <iostream>

int main()
{
    std::cout << std::setprecision(17);
    std::cout << 3.33333333333333333333333333333333333333f <<'\n';
    std::cout << 3.33333333333333333333333333333333333333 << '\n';

    return 0;
}
```

输出：

```
3.3333332538604736
3.3333333333333335
```

这表明 `float` 类型比 `double` 类型误差更大。

#### NaN 和 Inf

有两种特殊的浮点数类别：**Inf**（表示无穷大，正无穷或负无穷）和 **NaN**（表示“不是一个数字”）。以下代码展示了这两种情况：

```cpp
#include <iostream>

int main()
{
    double zero {0.0};
    double posinf { 5.0 / zero }; // 正无穷大
    std::cout << posinf << '\n';

    double neginf { -5.0 / zero }; // 负无穷大
    std::cout << neginf << '\n';

    double nan { zero / zero }; // 不是一个数字
    std::cout << nan << '\n';

    return 0;
}
```

可能的输出：

```
inf
-inf
nan
```

#### 总结

浮点数适用于存储非常大或非常小的数字，包括带有小数部分的数字。然而，浮点数经常会有一些微小的舍入误差，这些误差通常不明显，但它们确实存在，并可能影响数学运算的结果。

# 4.9 Boolean values

# 4.10 Introduction to `if` statements

# 4.11 Chars

# 4.12 Introduction to type conversion and `static_cast`

# 4.x Chapter 4 summary and quiz


