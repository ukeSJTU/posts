TODO 本章全部修改结束后移除本标记
# 5.1 - Constant variables (named constants) 常量变量（命名常量）

## 常量简介
在编程中，**常量** 是在程序执行过程中不能更改的值。

C++ 支持两种不同类型的常量：

1. **命名常量**：这些常量值与标识符相关联，有时也被称为符号常量，或者简单地称为常量。
2. **字面常量**：这些是与标识符无关的常量值。

我们将首先讨论 **命名常量**，然后在后续的 [[#5.2 Literals 字面量]] 中讨论 **字面常量**。
## 命名常量的类型
在 C++ 中，有三种方法可以定义命名常量：

1. **常量变量**（本课程会介绍）。
2. **带替换文本的对象宏**（我们在 [[Chapter 2 - C++ Basics - Functions and Files#2.10 Introduction to the preprocessor|2.10 — 预处理器简介]] 中介绍过，但在本课程中会进一步讨论）。
3. **枚举常量**（将在 [[Chapter 13 - Compound Types- Enums and Structs#13.2 Unscoped enumerations|13.2 — 无作用域枚举]] 中讨论）。

常量变量是最常见的命名常量类型，因此我们将从这里开始。
## 常量变量
到目前为止，我们见过的所有变量都是非常量的——也就是说，它们的值可以随时更改（通常通过赋值操作）。例如：

```cpp
int main()
{
    int x { 4 }; // x 是一个非常量变量
    x = 5; // 使用赋值运算符将 x 的值更改为 5

    return 0;
}
```

然而，在许多情况下，定义不可更改值的变量非常有用。比如说地球表面的重力加速度：9.8米/秒²。这在短时间内不太可能改变（如果真的改变了，可能会有比学习 C++ 更大的问题）。将这个值定义为常量可以确保它不会被意外更改。常量还有其他好处，我们将在后续课程中进一步探讨。

尽管这是个众所周知的矛盾修辞(oxymoron)，但在初始化后其值不能被更改的变量被称为 **常量变量**。
## 声明常量变量
要声明一个常量变量，我们将 `const` 关键字（称为“const 限定符”）放在对象类型的旁边：

```cpp
const double gravity { 9.8 };  // 推荐将 const 放在类型之前
int const sidesInSquare { 4 }; // "east const" 风格，不推荐但可以接受
```

虽然 C++ 可以接受将 `const` 限定符放在类型之前或之后，但通常使用 `const` 放在类型之前更为常见，因为它更符合英语语言习惯，修饰符通常在被修饰对象之前（例如“绿色的球”而不是“球绿色的”）。

> [!info] 顺便说一句
> 由于编译器解析一些更复杂的声明的方式，一些开发人员更喜欢将 `const` 放在类型之后（因为这稍微一致一些）。这种风格被称为“东 const”（east const）。虽然这种风格有一些拥护者（也有合理的理由），但它尚未广泛流行。

> [!tip] 最佳实践
> 将 `const` 放在类型之前（因为这更符合惯例）。

### 常量变量必须初始化
常量变量必须在定义时初始化，然后该值不能通过赋值更改：

```cpp
int main()
{
    const double gravity; // 错误：常量变量必须初始化
    gravity = 9.9;        // 错误：常量变量不能更改

    return 0;
}
```

注意，常量变量可以从其他变量（包括非常量变量）初始化：

```cpp
#include <iostream>

int main()
{
    std::cout << "请输入你的年龄：";
    int age{};
    std::cin >> age;

    const int constAge { age }; // 使用非常量值初始化常量变量

    age = 5;      // 可以：age 是非常量，因此可以更改其值
    constAge = 6; // 错误：constAge 是常量，因此不能更改其值

    return 0;
}
```

在上面的例子中，我们使用非常量变量 `age` 初始化了常量变量 `constAge`。因为 `age` 是非常量，我们可以更改它的值。然而，由于 `constAge` 是常量，因此我们不能更改它在初始化后的值。

> [!example] 关键见解
> 常量变量的初始化值可以是非常量的。

### 为常量变量命名
有多种命名常量变量的约定。

从 C 语言转过来的程序员通常喜欢使用带下划线的大写字母名称（例如 `EARTH_GRAVITY`）。C++ 中更常见的是使用驼峰式命名（也称为“大小写混合”） 的名称，并带有前缀 `k`（例如 `kEarthGravity`）。

然而，由于常量变量与普通变量类似（除了它们不能被赋值），因此不需要特殊的命名约定。所以，我们更倾向于使用与非常量变量相同的命名约定（例如 `earthGravity`）。
## 常量函数参数
函数参数可以通过 `const` 关键字定义为常量：

```cpp
#include <iostream>

void printInt(const int x)
{
    std::cout << x << '\n';
}

int main()
{
    printInt(5); // 5 将用作 x 的初始化值
    printInt(6); // 6 将用作 x 的初始化值

    return 0;
}
```

请注意，我们没有为常量参数 `x` 提供显式的初始化器——函数调用中的参数值将用作 `x` 的初始化值。

将函数参数定义为常量可以利用编译器帮助确保参数的值不会在函数内部更改。然而，在现代 C++ 中，我们不为按值传递的参数使用 `const`，因为我们通常不在乎函数是否更改参数的值（它只是一个副本，函数结束时将被销毁）。`const` 关键字还为函数原型添加了一些不必要的杂乱。

> [!tip] 最佳实践
> 当按值传递参数时，不要使用 `const`。

稍后在本教程中，我们将讨论另外两种传递参数的方法：按引用传递和按地址传递。在使用这两种方法时，正确使用 `const` 非常重要。
## 常量返回值

函数的返回值也可以定义为常量：

```cpp
#include <iostream>

const int getValue()
{
    return 5;
}

int main()
{
    std::cout << getValue() << '\n';

    return 0;
}
```

对于基本类型，返回类型上的 `const` 限定符会被忽略（编译器可能会生成警告）。

对于其他类型（我们将在后面讨论），按值返回常量对象通常没有什么意义，因为它们是临时副本，反正会被销毁。返回常量值还可能阻碍某些编译器优化（例如涉及移动语义的优化），从而导致性能下降。

> [!tip] 最佳实践
> 当按值返回时，不要使用 `const`。

## 带替换文本的对象宏
在 [[Chapter 2 - C++ Basics - Functions and Files#2.10 Introduction to the preprocessor|2.10 — 预处理器简介]] 中，我们讨论了带替换文本的对象宏。例如：

```cpp
#include <iostream>

#define MY_NAME "Alex"

int main()
{
    std::cout << "我的名字是：" << MY_NAME << '\n';

    return 0;
}
```

当预处理器处理包含此代码的文件时，它会将 `MY_NAME`（在第7行）替换为 `"Alex"`。请注意，`MY_NAME` 是名称，替换文本是常量值，因此带替换文本的对象宏也是命名常量。

## 优先使用常量变量而不是预处理器宏

那么，为什么不使用预处理器宏来定义命名常量呢？至少有三个主要问题。

1. **作用域问题**：宏不遵循 C++ 的正常作用域规则。一旦定义了宏，当前文件中所有后续出现的宏名都会被替换。如果该名称在其他地方使用，则会出现意外的宏替换，可能会导致奇怪的编译错误。

	```cpp
   #include <iostream>

   void someFcn()
   {
       // 即使 gravity 在此函数中定义，预处理器仍会替换此文件中的所有 gravity
       #define gravity 9.8
   }

   void printGravity(double gravity) // 包括这个，导致编译错误
   {
       std::cout << "gravity: " << gravity << '\n';
   }

   int main()
   {
       printGravity(3.71);

       return 0;
   }
   ```
   编译时，GCC 产生了如下错误：

	```bash
	   prog.cc:7:17: error: expected ',' or '...' before numeric constant
	       5 | #define gravity 9.8
	         |                 ^~~
	   prog
	
	.cc:10:26: note: in expansion of macro 'gravity'
	```

2. **调试困难**：虽然你的源代码包含宏名，但编译器和调试器在运行时看不到宏，因为它已经在预处理阶段被替换了。许多调试器无法检查宏的值，调试宏时功能有限。
   
3. **行为不一致**：宏替换的行为与 C++ 中的其他部分不同，可能导致意外的错误。

常量变量没有这些问题：它们遵循正常的作用域规则，可以被编译器和调试器看到，并且行为一致。

> [!tip] 最佳实践
> 优先使用常量变量而不是带替换文本的对象宏。

## 在多文件程序中使用常量变量
在许多应用中，给定的命名常量需要在整个代码中使用（而不仅仅是在一个文件中）。这些可以包括不会改变的物理或数学常量（例如 `pi` 或阿伏伽德罗常数），或者应用程序特定的“调优”值（例如摩擦或重力系数）。与其每次需要时重新定义它们，不如将它们声明在一个中央位置，并在需要的地方使用。这样，如果你以后需要更改它们，只需在一个地方更改即可。

C++ 中有多种方法可以实现这一点——我们将在 [[Chapter 7 - Scope, Duration, and Linkage#7.9 Sharing global constants across multiple files (using inline variables)|7.9 — 在多个文件中共享全局常量（使用内联变量）]] 中详细讨论这个话题。

## 类型限定符

类型限定符（有时简称为限定符）是一种应用于类型的关键字，用于修改该类型的行为。用于声明常量变量的 `const` 就是一种 `const` 类型限定符（简称 `const` 限定符）。

截至 C++23，C++ 只有两种类型限定符：`const` 和 `volatile`。

> [!quote] 可选阅读
> 
> **volatile** 限定符用于告知编译器某个对象的值可能随时发生变化。这个很少使用的限定符会禁用某些类型的优化。
>
> 在技术文档中，**const** 和 **volatile** 限定符通常被称为 **cv-限定符**。以下术语也在 C++ 标准中使用：
>
> - **cv-非限定类型** 是指没有任何类型限定符的类型（例如：`int`）。
> - **cv-限定类型** 是指应用了一个或多个类型限定符的类型（例如：`const int`）。
> - **可能的 cv-限定类型** 是指可以是 cv-非限定类型或 cv-限定类型的类型。
> 
> 这些术语在技术文档之外很少使用，因此在这里列出供参考，不需要特别记住。

# 5.2 - Literals 字面量
## 字面量简介

**字面量** 是直接插入到代码中的值。例如：

```cpp
return 5;                     // 5 是一个整数字面量
bool myNameIsAlex { true };    // true 是一个布尔字面量
double d { 3.4 };              // 3.4 是一个双精度字面量
std::cout << "Hello, world!";  // "Hello, world!" 是一个 C 风格的字符串字面量
```

字面量有时也被称为 **字面常量**，因为它们的含义不能被重新定义（例如，5 总是表示整数 5）。

## 字面量的类型

就像对象有类型一样，所有字面量也有类型。字面量的类型由其值推导而来。例如，一个整数字面量（如 `5`）的类型会被推导为 `int`。

### 默认字面量类型

| 字面量值类型  | 示例              | 默认字面量类型              | 备注                 |
| ------- | --------------- | -------------------- | ------------------ |
| 整数值     | 5, 0, -3        | `int`                |                    |
| 布尔值     | `true`, `false` | `bool`               |                    |
| 浮点值     | 1.2, 0.0, 3.4   | `double`（不是 `float`） |                    |
| 字符      | 'a', '\n'       | `char`               |                    |
| C 风格字符串 | "Hello, world!" | `const char[14]`     | 详见下文的 C 风格字符串字面量部分 |

### 字面量后缀

如果字面量的默认类型不是您所需要的，可以通过添加后缀来更改字面量的类型。以下是一些常见的后缀：

| 数据类型  | 后缀                                     | 含义                            |
| ----- | -------------------------------------- | ----------------------------- |
| 整数类型  | u 或 U                                  | 无符号整型（`unsigned int`）         |
| 整数类型  | l 或 L                                  | 长整型（`long`）                   |
| 整数类型  | ul, uL, Ul, UL, lu, lU, Lu, LU         | 无符号长整型（`unsigned long`）       |
| 整数类型  | ll 或 LL                                | 长长整型（`long long`）             |
| 整数类型  | ull, uLL, Ull, ULL, llu, llU, LLu, LLU | 无符号长长整型（`unsigned long long`） |
| 整数类型  | z 或 Z                                  | `std::size_t` 的有符号版本（C++23）   |
| 整数类型  | uz, uZ, Uz, UZ, zu, zU, Zu, ZU         | `std::size_t`（C++23）          |
| 浮点类型  | f 或 F                                  | 浮点型（`float`）                  |
| 浮点类型  | l 或 L                                  | 长双精度浮点型（`long double`）        |
| 字符串类型 | s                                      | `std::string`                 |
| 字符串类型 | sv                                     | `std::string_view`            |

大多数情况下，后缀并不是必需的，除了 `f` 后缀。

> [!info] 相关内容
> `s` 和 `sv` 后缀需要额外的代码行才能使用。我们将在 [[#5.9 — Introduction to `std string`|5.9 — std::string 简介]] 和 [[#5.10 Introduction to `std string_view`|5.10 — std::string_view 简介]] 中进一步介绍。

### 后缀大小写

大多数后缀不区分大小写。但下面是一些例外情况：

- `s` 和 `sv` 必须是小写的。
- 连续的两个 `l` 或 `L` 字符必须大小写一致。

由于小写字母 `l` 在某些字体中看起来像数字 `1`，一些开发人员更喜欢使用大写字母 `L` 后缀。

> [!tip] 最佳实践
> 使用大写字母 `L` 作为后缀，避免使用小写字母 `l`。

## 整数字面量

通常不需要为整数字面量使用后缀，但这里是一些示例：

```cpp
#include <iostream>

int main()
{
    std::cout << 5 << '\n';  // 5（无后缀）类型为 `int`
    std::cout << 5L << '\n'; // 5L 类型为 `long`
    std::cout << 5u << '\n'; // 5u 类型为 `unsigned int`

    return 0;
}
```

在大多数情况下，即使为非整型类型初始化，也可以使用无后缀的整数字面量：

```cpp
int main()
{
    int a { 5 };          // 正确：类型匹配
    unsigned int b { 6 }; // 正确：编译器将 int 值 6 转换为 unsigned int
    long c { 7 };         // 正确：编译器将 int 值 7 转换为 long

    return 0;
}
```

在这些情况下，编译器会将 `int` 字面量转换为适当的类型。

## 浮点字面量

默认情况下，浮点字面量的类型为 `double`。如果要将其设为 `float` 字面量，则需要使用 `f` 后缀：

```cpp
#include <iostream>

int main()
{
    std::cout << 5.0 << '\n';  // 5.0（无后缀）类型为 `double`
    std::cout << 5.0f << '\n'; // 5.0f 类型为 `float`

    return 0;
}
```

如果没有后缀，浮点字面量的类型为 `double`，这可能会导致编译器警告：

```cpp
float f { 4.1 }; // 警告：4.1 是 double 字面量，不是 float
```

解决方案可以是：

```cpp
float f { 4.1f }; // 使用 'f' 后缀，使字面量类型为 float
double d { 4.1 }; // 将变量类型改为 double 以匹配字面量
```

### 科学计数法的浮点字面量

浮点字面量有两种声明方式：

```cpp
double pi { 3.14159 }; // 标准表示法
double avogadro { 6.02e23 }; // 科学计数法
```

指数可以为负数：

```cpp
double electronCharge { 1.6e-19 }; // 表示 1.6 x 10^-19
```

## 字符串字面量

在编程中，**字符串**是一组用于表示文本（如名称、单词和句子）的字符。

例如：

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```

"Hello, world!" 是一个字符串字面量，字符串字面量使用双引号括起来。（这与 char 文本相反，后者放在单引号之间）。

由于程序经常需要使用字符串，因此大多数现代编程语言都包含基本的字符串数据类型。但由于历史原因，字符串不是 C++ 中的基本类型。相反，它们有一个奇怪、复杂的类型，很难使用（一旦我们涵盖了解释它们如何工作所需的更多基础知识，我们将在以后的课程中介绍如何/为什么）。此类字符串通常称为 **C 字符串**或 **C 样式字符串**，因为它们是从 C 语言继承的。

关于 C 样式字符串文字，有两件不是那么显然的事情值得你了解。
1. 所有 C 样式的字符串文字都有一个隐式的 null 终止符。考虑一个字符串，例如 `"hello"`虽然这个 C 风格的字符串看起来只有五个字符，但实际上它有六个字符：`'h'`、`'e'`、`'l``'l'`、`'o'` 和 `'\0'`（ASCII 码为 0 的字符）。此尾随 '\0' 字符是一个称为 **null 终止符**的特殊字符，用于指示字符串的结尾。以 null 终止符结尾的字符串称为**以 null 结尾的字符串**。

	> [!info] 对于高级读者
	>  这就是字符串 `"Hello, world!"` 的类型为 `const char[14]` 而不是 `const char[13]` 的原因 -- 隐藏的 null 终止符算作一个字符。
	
null 终止符的使用也是由历史原因决定的：它可以用来确定字符串的结束位置。
	
2. 与大多数其他字面量（它们是值，而不是对象）不同，C 样式字符串字面量是在程序开始时创建的 `const` 对象，并保证在整个程序中都存在。这个事实在几节课中讨论 `std::string_view` 时将变得很重要。
	
> [!example] 关键洞见
> C风格的字符串字面量是常量对象，它们在程序开始时创建，并且保证在整个程序运行期间一直存在。

与 C 样式的字符串文本不同，`std::string` 和 `std::string_view` 字面量创建的是临时对象。这些临时对象必须立即被使用，因为它们会在创建它们的完整表达式结束时被销毁。

> [!info] 相关内容
> 我们会分别在 [[#5.9 — Introduction to `std string`|5.9 课 - std::string 简介]] 和 [[#5.10 — std string_view 介绍|5.10 -- std：：string_view 中]] 讨论 `std::string` 和 `std::string_view` 字面量。

## 魔数

魔数是指没有明确意义或后续可能需要更改的字面量。

下面是两个使用“魔数”的例子：

```cpp
const int maxStudentsPerSchool{ numClassrooms * 30 };
setMax(30);
```

30 代表什么？在第一个例子中，可能代表每个班级的学生数量，但你第一眼可能也不清楚。第二个例子就更令人费解了，我们必须去查看函数本身才能知道它的作用。

在复杂的程序中，除非有注释来解释它，否则很难推断这种字面量（魔数）表示什么。

使用魔数通常被认为是不好的做法，因为它们不仅不提供上下文说明其用途，还会在数值需要更改时带来问题。假设学校购买了新课桌，允许将班级人数从30人增加到35人，而我们的程序需要反映这一变化。

为此，我们需要将某些字面量从30更新为35。但哪些字面量需要更新呢？`maxStudentsPerSchool`的初始值为30，似乎很明显需要更新。但`setMax()`函数中的30呢？这个30的含义和之前的30一样吗？如果一样，就需要更新；如果不一样，则应该保持不变，否则可能会在其他地方破坏程序的功能。如果你进行全局搜索并替换30，可能会无意中更新本不该改变的`setMax()`参数值。因此，你必须检查代码中所有30的实例（可能有数百个），并逐一判断是否需要更改。这非常耗时且容易出错。

幸运的是，缺少上下文和难以更新的问题都可以通过使用符号常量（而不是魔数）轻松解决：

```cpp
const int maxStudentsPerClass { 30 };
const int totalStudents{ numClassrooms * maxStudentsPerClass };

const int maxNameLength{ 30 };
setMax(maxNameLength);
```

常量的名称提供了上下文（这样我们第一眼就能理解这个值的作用）。而且我们只需要在一个位置更新一个值，即可在整个程序中更改该值。

请注意，魔数并不总是数字 -- 它们也可以是文本（例如姓名）或其他类型。

如果一个字面量不太可能更改并且被用在明显的上下文中，通常我们不认为它是魔数。例如，`-1`、`0`、`0.0`和`1`在以下场景中经常使用：

```cpp
int idGenerator { 0 };         // 可以接受：我们从0开始生成id
idGenerator = idGenerator + 1; // 可以接受：我们只是递增id生成器
```

或者在下面这种情况中，这个数字字面量的取值也是显而易见的（因此不被视为魔数）：

```cpp
int kmtoM(int km)
{
    return km * 1000; // 可以接受：1000显然是一个转换系数
}
```

> [!tip] 最佳实践
> 避免在代码中使用魔数（应使用 `constexpr` 变量，参见 [[#5.5 — Constexpr 变量|5.5 — `constexpr` 变量]]）。

# 5.3 数字系统（十进制、二进制、十六进制和八进制）

> [!quote] 作者注
> 
> 本课程是可选的。
> 
> 未来的课程会涉及十六进制数，所以在继续学习之前，你至少应该对这个概念有基本的了解。

在日常生活中，我们使用十进制数进行计数，每个数字可以是0、1、2、3、4、5、6、7、8或9。十进制也被称为"基数10"，因为有10个可能的数字（0到9）。在这个系统中，我们这样计数：0、1、2、3、4、5、6、7、8、9、10、11...默认情况下，C++程序中的数字被假定为十进制。

```cpp
int x { 12 }; // 12被假定为十进制数
```

在二进制中，只有2个数字：0和1，所以它被称为"基数2"。在二进制中，我们这样计数：0、1、10、11、100、101、110、111...

十进制和二进制是数字系统的两个例子，数字系统是用于表示数字的符号（如数字）的集合的专业名称。C++中有4种主要的数字系统。按受欢迎程度排序，它们是：十进制（基数10）、二进制（基数2）、十六进制（基数16）和八进制（基数8）。

TODO nomenclature 调整callouts 格式
## 命名法

在十进制和二进制中，数字0和1具有相同的含义。在这两个系统中，我们称这些数字为"零"和"一"。

但是10呢？10是在数字系统中最后一个单位数字之后出现的数字。在十进制中，10等于九加一。我们称这个数字为"十"。

在二进制中，10使用相同的数字，但等于一加一（相当于十进制的二）。把二进制的10称为"十"会造成混淆，因为"十"是九加一，而这个10是一加一。

因此，"十"、"十一"、"十二"等名称通常保留给十进制数。在非十进制数系统中，我们更倾向于称这些数字为一零、一一、一二等。二进制的101不是"一百零一"，而是"一零一"。

## 八进制和十六进制字面量

**八进制**是基数8 —— 也就是说，可用的数字只有：0、1、2、3、4、5、6和7。在八进制中，我们这样计数：0、1、2、3、4、5、6、7、10、11、12...（注意：没有8和9，所以我们从7直接跳到10）。

| 十进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
|--------|---|---|---|---|---|---|---|---|---|---|----|----|
| 八进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 11 | 12 | 13 |

要使用八进制字面量，在你的字面量前加上0（零）：

```cpp
#include <iostream>

int main()
{
    int x{ 012 }; // 数字前的0表示这是八进制
    std::cout << x << '\n';
    return 0;
}
```

这个程序打印：

```
10
```

为什么是10而不是12？因为默认情况下数字以十进制输出，而12（八进制）= 10（十进制）。

> [!tip] 最佳实践
> 
> 八进制几乎从不使用，我们建议你避免使用它。

**十六进制**是基数16。在十六进制中，我们这样计数：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F、10、11、12...

| 十进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
|--------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|----|----
| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | 10 | 11 |

你也可以使用小写字母（尽管大写更常见）。

要使用十六进制字面量，在你的字面量前加上0x：

```cpp
#include <iostream>

int main()
{
    int x{ 0xF }; // 数字前的0x表示这是十六进制
    std::cout << x << '\n';
    return 0;
}
```

这个程序会打印：

```
15
```

你也可以使用`0X`前缀，但`0x`是惯用的，因为它更容易阅读。

## 使用十六进制表示二进制

因为十六进制数字有16个不同的值，我们可以说一个十六进制数字可以表示4位二进制数。因此，一对十六进制数字可以精确地表示一个完整的字节。

| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
|----------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |

考虑一个二进制值为0011 1010 0111 1111 1001 1000 0010 0110的32位整数。由于数字的长度和重复，这不容易阅读。在十六进制中，这个相同的值将是：3A7F 9826，这要简洁得多。出于这个原因，十六进制值经常用于表示内存地址或内存中的原始数据（其类型未知）。

## 二进制字面量

在C++14之前，没有对二进制字面量的支持。然而，十六进制字面量为我们提供了一个有用的替代方案（你可能仍然会在现有的代码库中看到）：

```cpp
#include <iostream>

int main()
{
    int bin{};    // 假设16位整数
    bin = 0x0001; // 将二进制 0000 0000 0000 0001 赋值给变量
    bin = 0x0002; // 将二进制 0000 0000 0000 0010 赋值给变量
    bin = 0x0004; // 将二进制 0000 0000 0000 0100 赋值给变量
    bin = 0x0008; // 将二进制 0000 0000 0000 1000 赋值给变量
    bin = 0x0010; // 将二进制 0000 0000 0001 0000 赋值给变量
    bin = 0x0020; // 将二进制 0000 0000 0010 0000 赋值给变量
    bin = 0x0040; // 将二进制 0000 0000 0100 0000 赋值给变量
    bin = 0x0080; // 将二进制 0000 0000 1000 0000 赋值给变量
    bin = 0x00FF; // 将二进制 0000 0000 1111 1111 赋值给变量
    bin = 0x00B3; // 将二进制 0000 0000 1011 0011 赋值给变量
    bin = 0xF770; // 将二进制 1111 0111 0111 0000 赋值给变量

    return 0;
}
```

在C++14及以后的版本中，我们可以通过使用0b前缀来使用二进制字面量：

```cpp
#include <iostream>

int main()
{
    int bin{};        // 假设16位整数
    bin = 0b1;        // 将二进制 0000 0000 0000 0001 赋值给变量
    bin = 0b11;       // 将二进制 0000 0000 0000 0011 赋值给变量
    bin = 0b1010;     // 将二进制 0000 0000 0000 1010 赋值给变量
    bin = 0b11110000; // 将二进制 0000 0000 1111 0000 赋值给变量

    return 0;
}
```

## 数字分隔符

因为长字面量可能难以阅读，C++14还增加了使用引号（'）作为数字分隔符的能力。

```cpp
#include <iostream>

int main()
{
    int bin { 0b1011'0010 };  // 将二进制 1011 0010 赋值给变量
    long value { 2'132'673'462 }; // 比 2132673462 更容易阅读

    return 0;
}
```

还要注意，分隔符不能出现在值的第一个数字之前：

```cpp
int bin { 0b'1011'0010 };  // 错误：' 在值的第一个数字之前使用
```

数字分隔符纯粹是让阅读程序的人看起来更直观优雅，不会以任何方式影响字面量的值。

## 以十进制、八进制或十六进制输出值

默认情况下，C++以十进制输出值。然而，你可以通过使用 `std::dec`、`std::oct` 和 `std::hex` I/O 操纵器来改变输出格式：

```cpp
#include <iostream>

int main()
{
    int x { 12 };
    std::cout << x << '\n'; // 十进制（默认）
    std::cout << std::hex << x << '\n'; // 十六进制
    std::cout << x << '\n'; // 现在是十六进制
    std::cout << std::oct << x << '\n'; // 八进制
    std::cout << std::dec << x << '\n'; // 返回到十进制
    std::cout << x << '\n'; // 十进制

    return 0;
}
```

这会打印：

```
12
c
c
14
12
12
```

注意，一旦应用，I/O 操纵器会保持设置，直到再次改变。

## 以二进制输出值

以二进制输出值稍微复杂一些，因为 `std::cout` 没有内置这个功能。幸运的是，C++ 标准库包含了一个叫做 `std::bitset` 的类型，它可以为我们做这件事（在 `<bitset>` 头文件中）。

要使用 `std::bitset`，我们可以定义一个 `std::bitset` 变量，并告诉 `std::bitset` 我们想要存储多少位。位数必须是编译时常量。`std::bitset` 可以用整数值初始化（任何格式，包括十进制、八进制、十六进制或二进制）。

```cpp
#include <bitset> // 为了使用 std::bitset
#include <iostream>

int main()
{
	// std::bitset<8> 意味着我们想存储8位
	std::bitset<8> bin1{ 0b1100'0101 }; // 二进制字面量，表示二进制 1100 0101
	std::bitset<8> bin2{ 0xC5 }; // 十六进制字面量，表示二进制 1100 0101

	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{ 0b1010 } << '\n'; // 创建一个临时 std::bitset 并打印它

	return 0;
}
```

这会打印：

```
11000101
11000101
1010
```

在上面的代码中，这一行：

```cpp
std::cout << std::bitset<4>{ 0b1010 } << '\n'; // 创建一个临时 std::bitset 并打印它
```

创建了一个临时（未命名的）`std::bitset` 对象，包含4位，用二进制字面量 `0b1010` 初始化它，以二进制形式打印值，然后丢弃临时对象。

> [!info] 相关内容
> 
> 我们在 [[Chapter O - Bit Manipulation#O.1 Bit flags and bit manipulation via `std bitset`|O.1 课程 —— 通过 std::bitset 进行位标志和位操作]]中更详细地介绍了 `std::bitset`。

## 使用`format`库 / `print`库以二进制输出值（高级）

在 C++20 和 C++23 中，我们通过新的格式库（C++20）和打印库（C++23）有了更好的选择来打印二进制：

```cpp
#include <format> // C++20
#include <iostream>
#include <print> // C++23

int main()
{
    std::cout << std::format("{:b}\n", 0b1010);  // C++20, {:b} 将参数格式化为二进制数字
    std::cout << std::format("{:#b}\n", 0b1010); // C++20, {:#b} 将参数格式化为带 0b 前缀的二进制数字

    std::println("{:b} {:#b}", 0b1010, 0b1010);  // C++23, 格式化/打印两个参数（同上）并添加换行符

    return 0;
}
```

这会打印：

```
1010
0b1010
1010 0b1010
```

好的，我会按照您的要求进行格式调整。以下是根据您的要求调整后的翻译：

# 5.4 — Constant expressions and compile-time optimization 常量表达式和编译时优化

## as-if 规则

在 C++ 中，编译器被赋予了很大的自由度来优化程序。**as-if 规则**规定，编译器可以任意修改程序以产生更优化的代码，只要这些修改不影响程序的"可观察行为"。

> [!info] 面向高级读者
> 
> as-if 规则有一个例外：即使复制构造函数有可观察的行为，不必要的复制构造函数调用也可以被省略（elided）。我们将在 TODO 14.15 课程 —— 类初始化和复制省略中讨论这个主题。

编译器如何优化给定程序完全取决于编译器本身。然而，我们可以做一些事情来帮助编译器更好地优化。

## 优化机会

考虑以下简短程序：

```cpp
#include <iostream>

int main()
{
    int x { 3 + 4 };
    std::cout << x << '\n';

    return 0;
}
```

输出很简单：

```
7
```

然而，这里隐藏着一个有趣的优化可能性。

如果这个程序完全按照写的那样编译（没有优化），编译器会生成一个可执行文件，在运行时计算 3 + 4 的结果。如果程序执行一百万次，3 + 4 就会被计算一百万次，结果 7 也会被产生一百万次。

因为 3 + 4 的结果永远不会改变（总是 7），每次运行程序时重新计算这个结果是浪费的。

## 表达式的编译时求值

现代 C++ 编译器能够在编译时求值某些表达式。当这种情况发生时，编译器可以用表达式的结果替换表达式。

例如，编译器可以将上面的例子优化为：

```cpp
#include <iostream>

int main()
{
    int x { 7 };
    std::cout << x << '\n';

    return 0;
}
```

这个程序产生与之前版本相同的输出（7），但生成的可执行文件不再需要在运行时花费 CPU 周期来计算 3 + 4！更好的是，我们不需要做任何事情来启用这种行为（除了打开优化）。

> [!example] 关键见解
> 
> 编译时求值允许编译器在编译时完成原本在运行时才能完成的工作。
> 
> 这样的优化使我们的编译时间更长，但因为表达式只需要在编译时求值一次（而不是每次程序运行时都求值），所以生成的可执行文件更快，使用的内存更少。
> 
> C++ 执行编译时求值的能力是现代 C++ 最重要和不断发展的领域之一。

> [!quote] 作者注
> 
> 接下来的好几节课都将涉及编译时求值。

## 常量表达式

一种总是可以在编译时求值的表达式被称为"**常量表达式**"。常量表达式的精确定义很复杂，所以我们采用一个简化的观点：常量表达式是一个只包含编译时常量和支持编译时求值的运算符/函数的表达式。

> [!quote] 作者注
> 
> 更简单地说：常量表达式是一个表达式，其中表达式中的所有内容都可以在编译时求值。

**编译时常量**是一个值必须在编译时已知的常量。这包括：

- 字面量（例如 '5'，'1.2'）
- `constexpr` 变量（我们稍后会在 [[#5.5 — Constexpr 变量]] 讨论这些）
- 具有常量表达式初始化器的 `const` 整型变量（例如 `const int x { 5 };`）。这是一个历史例外 —— 在现代 C++ 中，`constexpr` 变量是首选。
- 非类型模板参数（见 [[Chapter 11 - Function Overloading and Function Templates#11.10 Non-type template parameters|11.10 - 非类型模板参数]]）。
- 枚举器（见 [[Chapter 13 - Compound Types- Enums and Structs#13.2 Unscoped enumerations|13.2 —— 无作用域枚举]]）。

不是编译时常量的 `const` 变量有时被称为运行时常量。运行时常量不能在常量表达式中使用。

> [!tip] 最佳实践
> 
> `const` 非整型变量始终是运行时常量（即使它们有常量表达式初始化器）。如果你需要这些变量成为编译时常量，请将它们定义为 `constexpr` 变量（见 [[#5.5 — Constexpr 变量]] ）。

最常见的支持编译时求值的运算符和函数类型包括：

- 操作数为编译时常量的算术运算符（例如 `1 + 2`）
- `constexpr` 和 `consteval` 函数（我们将在本章后面讨论这些）

在以下示例中，我们识别常量表达式和非常量表达式。我们还识别哪些变量是非常量、运行时常量或编译时常量。

```cpp
#include <iostream>

int getNumber()
{
    std::cout << "Enter a number: ";
    int y{};
    std::cin >> y;

    return y;
}

int main()
{
    // 非 const 变量始终是非常量：
    int a { 5 };                 // 5 是常量表达式
    double b { 1.2 + 3.4 };      // 1.2 + 3.4 是常量表达式

    // 具有常量表达式初始化器的 const 整型变量是编译时常量：
    const int c { 5 };           // 5 是常量表达式
    const int d { c };           // c 是常量表达式
    const long e { c + 2 };      // c + 2 是常量表达式

    // 其他 const 变量是运行时常量：
    const int f { a };           // a 不是常量表达式
    const int g { a + 1 };       // a + 1 不是常量表达式
    const int h { a + c };       // a + c 不是常量表达式
    const int i { getNumber() }; // getNumber() 不是常量表达式

    const double j { b };        // b 不是常量表达式
    const double k { 1.2 };      // 1.2 是常量表达式

    return 0;
}
```

`5` 是常量表达式，因为字面量 `5` 是编译时常量。`const int c { 5 }` 是编译时常量，因为它是具有常量表达式初始化器的 `const int` 变量。一旦被定义为这样，`c` 就可以在常量表达式中使用（比如 `d` 的初始化器）。

不是常量表达式的表达式有时被称为运行时表达式。例如，`std::cout << x << '\n'` 是一个运行时表达式，这是因为 x 不是编译时常量，而且当用于输出时，`operator<<` 不支持编译时求值（因为输出不能在编译时完成）。

## 为什么我们关心常量表达式

常量表达式至少有三个用处：

1. 常量表达式总是有资格进行编译时求值，这意味着它们更有可能在编译时被优化。这会产生更快、更小的代码。

2. 对于运行时表达式，只有表达式的类型在编译时是已知的。对于常量表达式，表达式的类型和值在编译时都是已知的。这允许我们对这些值进行编译时的合理性检查。如果这样的值不符合我们的要求，我们可以使构建失败，从而立即识别和修复问题。结果是更安全、更容易测试、更难误用的代码。

3. 我们将在未来课程中介绍的某些 C++ 特性需要常量表达式（见下文）。

> [!info] 面向高级读者
> 
> 以下是需要常量表达式的几个常见情况：
> 
> - `constexpr` 变量的初始化器（5.5 —— Constexpr 变量）。
> - 非类型模板参数（11.10 —— 非类型模板参数）。
> - `std::array`（17.1 —— std::array 介绍）或 C 风格数组（17.7 —— C 风格数组介绍）的定义长度。

> [!example] 关键见解
> 
> 常量表达式（包括我们即将讨论的 `constexpr` 变量和 `constexpr` 函数）可以帮助产生更快、更小、更安全的代码。一些 C++ 特性需要常量表达式。

## 常量表达式何时被求值？

编译器只需要在需要常量表达式的上下文中（例如编译时常量的初始化器）在编译时求值常量表达式。在不需要常量表达式的上下文中，编译器可以选择在编译时或运行时求值常量表达式。

```cpp
const int x { 3 + 4 }; // 常量表达式 3 + 4 必须在编译时求值
int y { 3 + 4 };       // 常量表达式 3 + 4 可能在编译时或运行时求值
```

因为变量 x 的类型是 `const int` 并且有一个常量表达式初始化器，所以它是一个编译时常量。它的初始化器必须在编译时求值（否则 x 的值在编译时就不知道，x 就不是编译时常量了）。

因为变量 y 不需要常量表达式初始化器，编译器可以选择在编译时或运行时求值 3 + 4。

即使在不需要的情况下，现代编译器通常也会在编译时求值常量表达式，因为这是一个简单的优化，而且这样做更高效。

> [!example] 关键见解
> 
> 编译器只需要在需要常量表达式的上下文中在编译时求值常量表达式。在其他情况下，它可能会或可能不会这样做。

## 常量子表达式的部分优化

现在考虑以下例子：

```cpp
#include <iostream>

int main()
{
    std::cout << 3 + 4 << '\n';

    return 0;
}
```

完整表达式 `std::cout << 3 + 4 << '\n';` 是一个运行时表达式，因为输出只能在运行时完成。但请注意，完整表达式包含常量子表达式 3 + 4。

> [!info] 相关内容
> 
> 我们在 [[Chapter 1 - C++ basics#1.10 Introduction to expressions|1.10 课程 —— 表达式介绍]] 中定义了"完整表达式"和"子表达式"这两个术语。

编译器长期以来就能够优化常量子表达式，即使完整表达式是一个运行时表达式。这种优化过程被称为"常量折叠"(constant folding)，并且在 as-if 规则下是允许的。

结果优化的代码看起来像这样：

```cpp
#include <iostream>

int main()
{
    std::cout << 7 << '\n';

    return 0;
}
```

## 非常量表达式的优化

编译器甚至能够在某些情况下优化非常量表达式或子表达式。让我们重新审视之前的一个例子：

```cpp
#include <iostream>

int main()
{
    int x { 7 };            // x 不是常量
    std::cout << x << '\n'; // x 是非常量子表达式

    return 0;
}
```

当 `x` 被初始化时，值 `7` 将被存储在为 `x` 分配的内存中。然后在下一行，程序将再次从内存中获取值 `7` 以便打印。

即使 x 是非 const 的，一个聪明的编译器可能会意识到在这个特定程序中 x 总是会求值为 7，并根据 as-if 规则将程序优化为：

```cpp
#include <iostream>

int main()
{
    int x { 7 };
    std::cout << 7 << '\n';

    return 0;
}
```

既然 `x` 在程序中不再被使用，编译器可以更进一步，将程序优化为：

```cpp
#include <iostream>

int main()
{
    std::cout << 7 << '\n';

    return 0;
}
```

在这个版本中，变量 `x` 被完全移除了（因为它没有被使用，因此不需要）。当一个变量从程序中移除时，我们说这个变量被优化掉了（或优化掉了）。

然而，由于 x 并不是常量，这样的优化需要编译器意识到 `x` 的值实际上没有改变（尽管它可能会改变）。编译器是否意识到这一点取决于程序自身的复杂程度和编译器优化例程的复杂程度。

## Const 变量更容易优化

现在让我们考虑这个类似的例子：

```cpp
#include <iostream>

int main()
{
    const int x { 7 }; // x 现在是 const
    std::cout << x << '\n';

    return 0;
}
```

在这个版本中，编译器不再需要推断 `x` 不会改变。因为 `x` 现在是常量，编译器现在可以保证 `x` 在初始化后无法更改。这使得编译器更容易理解它可以安全地优化该程序的 `x` ，因此更有可能这样做。

TODO quiz问答Q&A有待补充
# 5.5 `Constexpr` variables `Constexpr` 变量
TODO 翻译修改

在上一节课 5.4 中，我们讨论了常量表达式的定义及其为何重要。

> [!info] **提醒**
> 回顾一下常量表达式的好处，请参见 5.4 — 常量表达式与编译时优化。

我们还讨论了 C++ 有两种常量变量：**编译时常量变量**和**运行时常量变量**。只有编译时常量变量可以用于常量表达式，而运行时常量变量（以及非常量变量）则不行。

由于编译时常量变量没有实质上的缺点，我们通常希望在可能的情况下尽量使用编译时常量。

## 编译时 `const` 的挑战

在之前的课程中，我们提到了使用 `const` 关键字来创建编译时常量变量的方式。如果 `const` 变量具有整型类型并且有常量表达式初始化器，那么它就是编译时常量。其他的 `const` 变量则被视为运行时常量。

然而，这种方法存在两个挑战：

首先，使用 `const` 时，整型变量可能是编译时常量也可能是运行时常量，具体取决于初始化器是否为常量表达式。有时候这会让我们难以确定 `const` 变量是否真的为编译时常量。

例如：

```cpp
int a { 5 };       // 不是 const
const int b { a }; // 显然是运行时常量
const int c { 5 }; // 显然是编译时常量

const int d { someVar };    // 不清楚是运行时还是编译时常量
const int e { getValue() }; // 不清楚是运行时还是编译时常量
```

在上面的例子中，变量 `d` 和 `e` 可能是运行时常量或编译时常量，具体取决于 `someVar` 和 `getValue()` 的定义。在我们查找这些标识符的定义之前，不容易确认它们的类型。

第二，使用 `const` 创建编译时常量变量的方式不适用于非整型变量。但在许多情况下，我们也希望非整型变量成为编译时常量。

## `constexpr` 关键字

幸运的是，我们可以借助 `constexpr` 关键字来确保我们创建的变量是编译时常量。`constexpr` 是 “constant expression” 的缩写，表示声明的变量必须是编译时常量。如果初始化器不是常量表达式，则会产生编译错误。

例如：

```cpp
#include <iostream>

int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // 可以：9.8 是常量表达式
    constexpr int sum { 4 + 5 };      // 可以：4 + 5 是常量表达式
    constexpr int something { sum };  // 可以：sum 是常量表达式

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // 编译错误：age 不是常量表达式
    constexpr int f { five() };       // 编译错误：five() 的返回值不是常量表达式

    return 0;
}
```

由于函数通常在运行时执行，函数的返回值通常不是常量表达式，即使返回语句本身的值是常量。这就是为什么 `five()` 不能作为 `constexpr int f` 的初始化值。

> [!info] **相关内容**
> 我们将在 5.8 — `constexpr` 和 `consteval` 函数 中讨论可以用于常量表达式的函数。

另外，`constexpr` 也适用于非整型变量：

```cpp
constexpr double d { 1.2 }; // d 可以用于常量表达式！
```

## `const` 与 `constexpr` 的含义

对于变量来说：
- `const` 表示对象的值在初始化后不能更改。初始化器的值可以在编译时或运行时已知。`const` 对象可以在运行时求值。
- `constexpr` 表示该对象可以用于常量表达式。初始化器的值必须在编译时已知。`constexpr` 对象可以在运行时或编译时求值。

`constexpr` 变量隐含地是 `const` 的，而 `const` 变量并不隐含为 `constexpr`（除非是具有常量表达式初始化器的整型变量）。

虽然变量可以同时定义为 `constexpr` 和 `const`，但在大多数情况下，这是多余的，我们只需使用 `const` 或 `constexpr` 之一即可。

> [!best-practice] **最佳实践**
> - 如果常量变量的初始化器是常量表达式，应将其声明为 `constexpr`。
> - 如果常量变量的初始化器不是常量表达式（即为运行时常量），应将其声明为 `const`。

> [!warning] **注意**
> 有些类型并不完全兼容 `constexpr`，包括 `std::string`、`std::vector` 以及其他使用动态内存分配的类型。对于这些类型的常量对象，建议使用 `const` 而不是 `constexpr`，或者选择其他兼容 `constexpr` 的类型（例如 `std::string_view` 或 `std::array`）。

## 命名法

`constexpr` 是“constant expression”的缩写。这个名称是因为 `constexpr` 对象（以及函数）可以用于常量表达式。

正式来说，`constexpr` 关键字只适用于对象和函数。然而，`constexpr` 通常作为常量表达式的简写。

> [!info] **作者注**
> 本站点上的一些示例是在 `constexpr` 成为最佳实践之前编写的，因此您可能会注意到一些示例并没有遵循上述最佳实践。我们正在更新不符合最佳实践的示例。

## `const` 和 `constexpr` 函数参数

普通函数调用在运行时求值，提供的参数用于初始化函数的参数。由于函数参数的初始化在运行时进行，因此有以下两个后果：
- `const` 函数参数被视为运行时常量（即使提供的参数是编译时常量）。
- 函数参数不能声明为 `constexpr`，因为它们的初始化值直到运行时才确定。

> [!info] **相关内容**
> C++ 支持可以在编译时求值的函数，我们将在 5.8 — `constexpr` 和 `consteval` 函数 中讨论这些函数。

## 术语回顾

| 术语                  | 定义                                                           |
| --------------------- | ------------------------------------------------------------- |
| 编译时常量            | 必须在编译时已知值的不可修改对象（例如字面量和 `constexpr` 变量）。|
| `constexpr`           | 声明变量为编译时常量的关键字（以及可以在编译时求值的函数）。    |
| 常量表达式            | 仅包含编译时常量和支持编译时求值的运算符/函数的表达式。         |
| 运行时表达式          | 非常量表达式。                                                 |
| 运行时常量            | 不是编译时常量的不可修改对象。                                   |

# 5.6 The conditional operator - 条件运算符
TODO 翻译修改

| 运算符   | 符号   | 形式          | 含义                           |
| ----- | ---- | ----------- | ---------------------------- |
| 条件运算符 | `?:` | `c ? x : y` | 如果条件 `c` 为真，则计算 `x`，否则计算 `y` |

条件运算符 `?:`（有时也称为**三元运算符**）是一个三元运算符（即它接受3个操作数）。由于历史上 C++ 只有这个三元运算符，它也被称为“三元运算符”。

`?:` 运算符提供了一种简化的方式来编写某类 `if-else` 语句。

> [!info] **相关内容**
> 我们在 4.10 课中介绍了 `if-else` 语句。

## 条件运算符语法回顾

`if-else` 语句的形式如下：

```cpp
if (condition)
    statement1;
else
    statement2;
```

如果 `condition` 为真，则执行 `statement1`，否则执行 `statement2`。其中 `else` 和 `statement2` 是可选的。

而条件运算符的形式如下：

```cpp
condition ? expression1 : expression2;
```

如果 `condition` 为真，则计算 `expression1`，否则计算 `expression2`。在条件运算符中，`: expression2` 是**必须**的。

举个例子：

```cpp
if (x > y)
    greater = x;
else
    greater = y;
```

这可以简化为：

```cpp
greater = ((x > y) ? x : y);
```

在这种情况下，条件运算符可以使代码更加紧凑，同时不会失去可读性。

## 条件运算符作为表达式求值

由于条件运算符的操作数是表达式而非语句，条件运算符可以在需要表达式的地方使用。

例如，初始化变量时：

```cpp
#include <iostream>

int main()
{
    constexpr bool inBigClassroom { false };
    constexpr int classSize { inBigClassroom ? 30 : 20 };
    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```

没有直接的 `if-else` 语句可以替换这段代码。如果尝试以下代码：

```cpp
#include <iostream>

int main()
{
    constexpr bool inBigClassroom { false };

    if (inBigClassroom)
        constexpr int classSize { 30 };
    else
        constexpr int classSize { 20 };

    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```

这段代码无法编译，因为变量 `classSize` 超出了作用域，已经被销毁。

因此，如果需要使用 `if-else`，可以这样做：

```cpp
#include <iostream>

int getClassSize(bool inBigClassroom)
{
    if (inBigClassroom)
        return 30;
    else
        return 20;
}

int main()
{
    const int classSize { getClassSize(false) };
    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```

尽管这可以工作，但我们可以使用条件运算符简化代码。

## 条件运算符的优先级

由于 C++ 会优先计算大多数运算符，因此在复合表达式中使用条件运算符时，可能不会按预期方式进行求值。

例如：

```cpp
#include <iostream>

int main()
{
    int x { 2 };
    int y { 1 };
    int z { 10 - x > y ? x : y };
    std::cout << z;

    return 0;
}
```

我们可能期望它按 `10 - (x > y ? x : y)` 进行求值（结果为 8），但实际上它按 `(10 - x) > y ? x : y` 进行求值（结果为 2）。

因此，建议在复合表达式中对条件操作进行括号化：

```cpp
int z { (x > y) ? x : y };
```

## 条件运算符的类型匹配

为了符合 C++ 的类型检查规则，必须满足以下条件之一：
- 第二个和第三个操作数的类型必须匹配。
- 编译器必须能够找到方法将两个操作数之一或两个都转换为相同的类型。

例如：

```cpp
#include <iostream>

int main()
{
    std::cout << (true ? 1 : 2) << '\n';    // 可以：两个操作数都是 int
    std::cout << (false ? 1 : 2.2) << '\n'; // 可以：int 值 1 转换为 double
    std::cout << (true ? -1 : 2u) << '\n';  // 令人惊讶的结果：-1 转换为 unsigned int，结果超出范围

    return 0;
}
```

输出结果为：

```
1
2.2
4294967295
```

如果编译器找不到匹配类型，则会出现编译错误：

```cpp
#include <iostream>

int main()
{
    constexpr int x{ 5 };
    std::cout << ((x != 5) ? x : "x is 5"); // 编译错误：编译器无法为 int 和字符串字面量找到共同类型

    return 0;
}
```

在这种情况下，您可以进行显式转换，或使用 `if-else` 语句。

## 何时使用条件运算符？

条件运算符最适合在以下情况下使用：
- 初始化对象时选择两个值之一。
- 为对象分配两个值之一。
- 向函数传递两个值之一。
- 从函数返回两个值之一。
- 打印两个值之一。

在复杂表达式中应避免使用条件运算符，因为它们容易出错且难以阅读。

> [!best-practice] **最佳实践**
> 避免在复杂表达式中使用条件运算符。


# 5.7 Inline functions and variables - 内联函数和变量
TODO 翻译修改

当你需要编写一些代码来执行某个具体任务时，比如从用户获取输入、将内容输出到文件或计算某个特定值，你有两个基本选择：

1. 将代码写在已有函数的一部分（称为“内联”代码）。
2. 创建一个函数（可能还有子函数）来处理任务。

编写函数有许多潜在的好处，因为函数中的代码：

- 更易于在整个程序的上下文中阅读和理解。
- 更易于使用，因为你可以调用函数而不必理解其内部实现。
- 更易于更新，因为函数中的代码可以在一个地方更新。
- 更易于重用，因为函数本身就是模块化的。

然而，使用函数的一个缺点是，每次调用函数时，都会有一定的性能开销。比如，考虑以下代码：

```cpp
#include <iostream>

int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

每次调用 `min()` 时，CPU 都必须保存当前指令的地址（以便稍后知道返回到哪里）以及各种 CPU 寄存器的值（以便返回时可以恢复）。然后，参数 `x` 和 `y` 必须被实例化和初始化。之后，执行路径跳转到 `min()` 函数中的代码。当函数结束时，程序必须跳回到函数调用的位置，并复制返回值以便输出。这些步骤需要在每次调用函数时执行。

所有这些为了设置、执行和清理某个任务（在这个例子中是函数调用）所需要的额外工作被称为**开销**。

对于大型或复杂任务的函数来说，函数调用的开销相对于函数执行时间来说通常是可以忽略的。然而，对于像 `min()` 这样的小函数来说，调用函数的开销可能比实际执行函数的代码所需的时间还要长！在小函数被频繁调用的情况下，使用函数可能会导致相较于直接在代码中实现任务有显著的性能损失。

## 内联展开

幸运的是，C++ 编译器有一种技巧可以用来避免这种开销：**内联展开**（Inline Expansion），这是一个将函数调用替换为被调用函数定义中的代码的过程。

例如，如果编译器在上述例子中展开了 `min()` 调用，生成的代码将如下所示：

```cpp
#include <iostream>

int main()
{
    std::cout << ((5 < 6) ? 5 : 6) << '\n';
    std::cout << ((3 < 2) ? 3 : 2) << '\n';
    return 0;
}
```

注意，两个对 `min()` 函数的调用已被替换为函数体中的代码（参数的值替换为参数变量）。这样我们可以避免调用函数的开销，同时保留代码的结果。

## 内联代码的性能

除了消除函数调用的成本之外，内联展开还允许编译器更高效地优化生成的代码。例如，由于表达式 `((5 < 6) ? 5 : 6)` 现在是一个常量表达式，编译器可以进一步优化 `main()` 中的第一个语句为 `std::cout << 5 << '\n';`。

然而，内联展开也有潜在的成本：如果被展开的函数体比被替换的函数调用需要更多的指令，那么每次内联展开都会使可执行文件变得更大。较大的可执行文件通常较慢（因为它们不能很好地适应内存缓存）。

关于函数是否应该内联展开的决策并不简单。内联展开可能会带来性能提升、性能下降，或者没有任何变化，具体取决于函数调用的成本、函数的大小以及可以执行的其他优化。

内联展开最适合于简单、短小的函数（例如不超过几条语句），特别是在一个函数调用可以多次执行的情况下（例如循环中的函数调用）。

## 什么时候会发生内联展开？

每个函数都属于以下两类之一：
1. 可能会展开（大多数函数属于这一类）。
2. 不能展开。

大多数函数属于“可能”这一类：如果有好处，它们的函数调用可以展开。对于这些函数，现代编译器会评估每个函数和每个函数调用，以确定是否有益于展开内联调用。编译器可能决定展开某些函数调用，也可能决定不展开。

> [!tip] **提示**
> 现代优化编译器会决定何时应该内联展开函数。

### `inline` 关键字的历史

历史上，编译器要么没有能力确定内联展开是否有益，要么在这方面不够好。出于这个原因，C++ 提供了 `inline` 关键字，最初用于向编译器提示某个函数可能会从内联展开中受益。

声明为 `inline` 的函数被称为**内联函数**。

```cpp
#include <iostream>

inline int min(int x, int y) // `inline` 关键字表示这是一个内联函数
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

但是，在现代 C++ 中，`inline` 关键字不再用于请求内联展开。原因如下：

- 使用 `inline` 来请求内联展开是一种过早的优化，滥用可能会降低性能。
- `inline` 关键字只是给编译器的一个提示，编译器可以忽略它。编译器也可以在没有 `inline` 关键字的情况下对函数进行内联展开。
- `inline` 关键字在错误的粒度上定义。我们在函数定义上使用 `inline`，但内联展开实际上是在函数调用的层面上决定的。可能某些函数调用适合展开，而其他调用则不适合，但没有语法来影响这种决策。
- 现代优化编译器在确定哪些函数调用应该内联时通常表现得很好——大多数情况下比人类更好。

> [!best-practice] **最佳实践**
> 不要使用 `inline` 关键字请求内联展开。

### `inline` 关键字的现代用途

在之前的章节中，我们提到你不应该在头文件中实现具有外部链接的函数，因为当这些头文件被多个 `.cpp` 文件包含时，函数定义将被复制到多个 `.cpp` 文件中。这些文件将被编译，链接器会抛出错误，因为它会注意到你多次定义了相同的函数，这违反了一次定义规则（ODR）。

在现代 C++ 中，`inline` 的含义已经演变为“允许多个定义”。因此，内联函数是一种允许在多个翻译单元中定义的函数（不会违反 ODR）。

内联函数有两个主要要求：

1. 编译器需要能够在每个翻译单元中看到内联函数的完整定义（仅仅提供前向声明是不够的）。每个翻译单元最多只能包含一个这样的定义，否则会出现编译错误。
2. 所有对同一内联函数的定义必须完全相同，否则会导致未定义行为。

> [!rule] **规则**
> 编译器需要能够在函数使用的每个地方看到内联函数的完整定义，所有这些定义必须相同，否则将导致未定义行为。

## 内联变量（C++17）

从 C++17 开始，C++ 引入了内联变量，允许在多个文件中定义变量。内联变量的工作方式与内联函数类似，具有相同的要求（编译器必须能够在使用变量的地方看到完全相同的定义）。

### 示例代码

```cpp
// pi.h

#ifndef PI_H
#define PI_H

inline double pi() { return 3.14159; }

#endif

// main.cpp

#include "pi.h"
#include <iostream>

int main()
{
    std::cout << pi() << '\n';
    return 0;
}

// math.cpp

#include "pi.h"

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```

### 何时使用 `inline` 关键字？

除非有具体的需求（如需要在头文件中定义函数或变量），否则应避免使用 `inline` 关键字。

> [!best-practice] **最佳实践**
> 避免使用 `inline` 关键字，除非你有具体的需求。


# 5.8 `Constexpr` and `consteval` functions

TODO 本节内容全部需要重新翻译，有缺漏
在第5.5节——`constexpr`变量中，我们介绍了`constexpr`关键字，用它可以创建编译时（符号）常量。我们还介绍了常量表达式，常量表达式可以在编译时而不是运行时进行求值。

常量表达式的一个挑战是对普通函数的调用不允许在常量表达式中使用。这意味着我们无法在任何需要常量表达式的地方使用普通函数调用。

考虑以下程序：

```cpp
#include <iostream>

int main()
{
    constexpr double radius { 3.0 };
    constexpr double pi { 3.14159265359 };
    constexpr double circumference { 2.0 * radius * pi };

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```

该程序产生的结果为：

```
Our circle has circumference 18.8496
```

将`circumference`的初始化复杂化不是最好的做法（并且我们还需要实例化两个辅助变量`radius`和`pi`）。因此，让我们把它变成一个函数：

```cpp
#include <iostream>

double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) }; // 编译错误

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```

这个代码更简洁，但它不会编译。`constexpr`变量`circumference`要求其初始化器是一个常量表达式，而`calcCircumference()`的调用并不是一个常量表达式。

### `constexpr`函数可以用于常量表达式

要使函数成为`constexpr`函数，只需在函数的返回类型前加上`constexpr`关键字。

#### 关键洞察

`constexpr`关键字用于向编译器和其他开发者表示一个函数可以用于常量表达式。

以下是使用`constexpr`函数的同一例子：

```cpp
#include <iostream>

constexpr double calcCircumference(double radius) // 现在是一个`constexpr`函数
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) }; // 现在可以编译

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```

由于`calcCircumference()`现在是一个`constexpr`函数，它可以用于常量表达式，例如`circumference`的初始化。

### `constexpr`函数可以在编译时求值

在第5.4节——常量表达式和编译时优化中，我们提到，在需要常量表达式的上下文中，`constexpr`函数必须在编译时进行求值。

在我们上面的例子中，`circumference`是`constexpr`的，因此要求一个常量表达式初始化器。由于`calcCircumference()`是这个常量表达式的一部分，`calcCircumference()`必须在编译时进行求值。

当函数调用在编译时求值时，编译器将在编译时计算函数调用的返回值，然后将函数调用替换为返回值。

### `constexpr`函数也可以在运行时求值

```cpp
#include <iostream>

constexpr int greater(int x, int y)
{
    return (x > y ? x : y);
}

int main()
{
    int x{ 5 }; // 不是`constexpr`
    int y{ 6 }; // 不是`constexpr`

    std::cout << greater(x, y) << " is greater!\n"; // 将在运行时求值

    return 0;
}
```

在这个例子中，由于参数`x`和`y`不是常量表达式，函数不能在编译时解析。但是，该函数仍将在运行时解析，返回预期值作为非`constexpr`的`int`。

### `constexpr`函数调用不要求在编译时求值

在上下文不要求常量表达式时，`constexpr`函数可以在编译时或运行时进行求值。例如：

```cpp
#include <iostream>

constexpr int getValue(int x)
{
    return x;
}

int main()
{
    int x { getValue(5) }; // 可能在运行时或编译时求值

    return 0;
}
```

在这个例子中，`getValue(5)`是一个常量表达式，但是因为变量`x`不是`constexpr`，编译器可以选择在编译时或运行时进行求值。

#### 关键洞察

只有当上下文要求常量表达式时，`constexpr`函数才会在编译时进行求值。

### 诊断`constexpr`函数

编译器不需要在函数定义时确定`constexpr`函数是否能在编译时求值，直到它实际上在编译时求值。编写的`constexpr`函数在运行时使用时可能会成功，但在编译时使用时会失败。

#### 最佳实践

所有`constexpr`函数应在编译时可求值，因为在需要常量表达式的上下文中，它们将被要求进行编译时求值。

总之，`constexpr`函数可以在编译时或运行时求值，`consteval`函数只能在编译时求值，使用`constexpr`和`consteval`可以显著提高代码的灵活性和性能。



# 5.9 Introduction to `std::string`

在第5.2节——字面量中，我们介绍了C风格的字符串字面量：

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!"; // "Hello world!" 是一个C风格的字符串字面量。
    return 0;
}
```

虽然C风格的字符串字面量可以使用，但C风格的字符串变量的行为比较奇怪，难以使用（例如，不能通过赋值操作为C风格的字符串变量赋新值），而且不安全（例如，如果将更大的C风格字符串复制到为较短的字符串分配的空间中，结果可能是未定义的行为）。在现代C++中，C风格的字符串变量应尽量避免使用。

幸运的是，C++引入了两种更容易使用且更安全的字符串类型：`std::string`和`std::string_view`（C++17）。虽然它们不是基本类型（它们是类类型），但它们的基本使用非常简单且实用，值得在这里介绍。

### 介绍 `std::string`

在C++中，处理字符串和字符串对象最简单的方法是使用`std::string`类型，它位于`<string>`头文件中。

我们可以像其他对象一样创建`std::string`类型的对象：

```cpp
#include <string> // 允许使用std::string

int main()
{
    std::string name {}; // 空字符串

    return 0;
}
```

你可以像其他变量一样对`std::string`对象进行初始化或赋值：

```cpp
#include <string>

int main()
{
    std::string name { "Alex" }; // 用字符串字面量"Alex"初始化name
    name = "John";               // 将name修改为"John"

    return 0;
}
```

### 使用`std::cout`输出`std::string`

`std::string`对象可以像预期的那样使用`std::cout`进行输出：

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name { "Alex" };
    std::cout << "My name is: " << name << '\n';

    return 0;
}
```

这将输出：

```
My name is: Alex
```

### 使用`std::getline()`读取完整行

为了从用户输入中读取一整行，使用`std::getline()`比使用`>>`操作符更合适。`std::getline()`需要两个参数：第一个是`std::cin`，第二个是你的字符串变量。

```cpp
#include <iostream>
#include <string> // 用于std::string和std::getline

int main()
{
    std::cout << "Enter your full name: ";
    std::string name{};
    std::getline(std::cin >> std::ws, name); // 读取整行文本到name中

    std::cout << "Your name is: " << name << '\n';

    return 0;
}
```

### 获取`std::string`的长度

我们可以使用`std::string::length()`成员函数获取字符串的长度：

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name{ "Alex" };
    std::cout << name << " has " << name.length() << " characters\n";

    return 0;
}
```

这将输出：

```
Alex has 4 characters
```

虽然`std::string`必须是以空字符结尾的（从C++11起），但返回的长度不包括隐式的空终止符。

### 不要按值传递`std::string`

当`std::string`按值传递给函数时，函数的参数必须用参数的副本进行初始化，这是一个昂贵的操作。通常，建议使用`std::string_view`作为参数类型（将在第5.10节介绍）。

### 返回`std::string`

虽然传递`std::string`时不应按值传递，但在某些情况下从函数返回`std::string`是可以的，尤其是当返回的是局部变量或临时对象时。

### 总结

`std::string`非常强大且灵活，它在现代C++中提供了方便和安全的字符串操作。通过使用`std::getline()`进行输入，以及利用`std::string::length()`获取字符串的长度，处理字符串变得更加容易和直观。

### 练习题

编写一个程序，要求用户输入他们的全名和年龄，并输出年龄加上名字的字母数（使用`std::string::length()`来获取字符串的长度）。考虑到名字中可能包含空格，将空格也计算为一个字母。

**示例输出：**

```
Enter your full name: John Doe
Enter your age: 32
Your age + length of name is: 40
```

**解决方案：**

```cpp
#include <iostream>
#include <string>

int main()
{
    std::cout << "Enter your full name: ";
    std::string name{};
    std::getline(std::cin >> std::ws, name); // 读取整行文本到name中

    std::cout << "Enter your age: ";
    int age{}; // age需要是整数类型，因为我们要进行数学运算
    std::cin >> age;

    int letters{ static_cast<int>(name.length()) }; // 获取名字的字符数（包括空格）
    std::cout << "Your age + length of name is: " << age + letters << '\n';

    return 0;
}
```

这个程序将按预期工作，输出用户年龄与名字长度的和。

### 5.9 — 继续讨论 `std::string`

### 初始化 `std::string` 的性能开销

当一个 `std::string` 被初始化时，字符串的副本会被创建。创建字符串副本的开销较大，因此在实际开发中，应尽量减少副本的数量。

#### 传递 `std::string` 的最佳方式

避免按值传递 `std::string`。这会产生昂贵的副本操作，尤其是当字符串较大时。如果你确实需要在函数中使用字符串而不修改它的内容，推荐使用 `std::string_view` 来避免复制，这将在 5.10 章详细介绍。

**最佳实践：**
避免按值传递 `std::string`，这会导致不必要的副本操作，影响性能。

### 返回 `std::string`

在函数中返回 `std::string` 时，如果返回的是局部变量或者临时对象（即该对象会在函数返回后销毁），C++ 的 "移动语义" 将优化这些返回操作，避免拷贝行为。不过，这仅在 C++11 及其之后的标准中有效。如果返回的不是局部变量或临时对象，那么直接返回 `std::string` 可能会带来一定的性能损失。

**示例：**
```cpp
#include <iostream>
#include <string>

std::string generateMessage() {
    return "Hello, World!";
}

int main() {
    std::string message = generateMessage();
    std::cout << message << '\n';
    return 0;
}
```

在这个例子中，`generateMessage()` 函数返回一个临时的 `std::string`，因此 C++11 及更高版本中，将会进行"移动"而不是复制操作，从而避免性能开销。

**最佳实践：**
在可以优化时，通过值返回 `std::string` 是可行的，但如果你要频繁返回大型字符串或非局部变量，可能需要重新考虑设计。

### `std::string` 的字面量支持

默认情况下，双引号括起来的字符串字面量（例如 `"Hello, World!"`）是 C 风格的字符串字面量。然而，在 C++11 及更高版本中，我们可以通过在字符串后加上 `s` 后缀来创建 `std::string` 字面量。

**示例：**
```cpp
#include <iostream>
#include <string>

int main() {
    using namespace std::string_literals; // 引入`s`字面量

    std::string str = "Hello"s; // s 后缀将字面量转换为 std::string
    std::cout << str << '\n';

    return 0;
}
```

**提示：**
使用 `using namespace std::string_literals` 允许你在代码中更简便地使用 `s` 字面量。

### `std::string` 的动态内存分配

`std::string` 背后使用的是动态内存分配，这意味着当字符串长度发生变化时，`std::string` 会自动请求更多的内存。这使得 `std::string` 非常灵活，但也带来了额外的性能开销。因此，如果你的应用程序对性能要求较高，可能需要考虑这些动态内存分配的影响。

**关键见解：**
`std::string` 的动态内存分配使它可以处理任意长度的字符串，但代价是性能较慢，特别是在频繁扩展字符串时。

### 总结

`std::string` 是 C++ 提供的强大且灵活的字符串处理类，它极大地简化了字符串的操作，避免了 C 风格字符串带来的很多风险和麻烦。尽管背后有复杂的实现，但对于日常的字符串处理，你只需要关注基本用法，如使用 `std::getline()` 输入、`std::cout` 输出以及 `std::string::length()` 获取字符串长度。

如果你不需要修改字符串的内容，`std::string_view` 会是一个更轻量级的选择，我们将在接下来的章节深入介绍 `std::string_view`。

---

接下来，如果你希望进一步优化性能，建议了解 `std::string_view`，它是现代C++中的一个高效字符串查看器，允许我们查看字符串的某个子集，而不需要进行复制操作。



# 5.10 Introduction to `std::string_view`

### 5.10 — std::string_view 介绍
nascardriver  2024年1月10日

考虑以下程序：

```cpp
#include <iostream>

int main()
{
    int x { 5 }; // x 对初始化值进行了复制
    std::cout << x << '\n';

    return 0;
}
```

当 x 定义时，初始化值 5 被复制到分配给变量 int x 的内存中。对于基本类型来说，初始化和复制变量的速度很快。

现在考虑这个类似的程序：

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string s{ "Hello, world!" }; // s 对初始化值进行了复制
    std::cout << s << '\n';

    return 0;
}
```

当 s 初始化时，C 风格的字符串字面量 `"Hello, world!"` 被复制到分配给 `std::string s` 的内存中。与基本类型不同，初始化和复制一个 `std::string` 是比较慢的操作。

在上述程序中，我们对 s 所做的所有操作只是将值打印到控制台，之后 s 被销毁。我们实际上只是为了打印然后销毁字符串的副本，这样做效率不高。

我们在下面的例子中看到类似的情况：

```cpp
#include <iostream>
#include <string>

void printString(std::string str) // str 对初始化值进行了复制
{
    std::cout << str << '\n';
}

int main()
{
    std::string s{ "Hello, world!" }; // s 对初始化值进行了复制
    printString(s);

    return 0;
}
```

这个例子对 C 风格字符串 `"Hello, world!"` 进行了两次复制：一次是在 `main()` 中初始化 s 时，另一次是在初始化 `printString()` 中的参数 str 时。为了仅仅打印一个字符串，进行这么多无谓的复制并不高效！

### `std::string_view` (C++17)

为了解决 `std::string` 初始化（或复制）开销大问题，C++17 引入了 `std::string_view`（位于 `<string_view>` 头文件中）。`std::string_view` 提供对现有字符串（C 风格字符串、`std::string` 或其他 `std::string_view`）的只读访问，而无需进行复制。只读意味着我们可以访问和使用所查看的值，但不能修改它。

下面的例子与前一个例子相同，只是我们将 `std::string` 替换为了 `std::string_view`。

```cpp
#include <iostream>
#include <string_view> // C++17

// str 提供对传递进来的参数的只读访问
void printSV(std::string_view str) // 现在是 std::string_view
{
    std::cout << str << '\n';
}

int main()
{
    std::string_view s{ "Hello, world!" }; // 现在是 std::string_view
    printSV(s);

    return 0;
}
```

这个程序输出和前一个相同，但没有对字符串 `"Hello, world!"` 进行任何复制。

当我们用 C 风格的字符串字面量 `"Hello, world!"` 初始化 `std::string_view s` 时，`s` 提供了对 `"Hello, world!"` 的只读访问，而不复制字符串。当我们将 s 传递给 `printSV()` 时，参数 `str` 从 s 初始化。这允许我们通过 `str` 访问 `"Hello, world!"`，同样不需要复制字符串。

**最佳实践：**

在需要只读字符串时，优先选择 `std::string_view` 而不是 `std::string`，尤其是在函数参数中。

### `std::string_view` 可以用多种不同类型的字符串初始化

`std::string_view` 的一个强大之处在于它的灵活性。一个 `std::string_view` 对象可以使用 C 风格的字符串、`std::string` 或另一个 `std::string_view` 进行初始化：

```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string_view s1 { "Hello, world!" }; // 使用 C 风格字符串字面量初始化
    std::cout << s1 << '\n';

    std::string s{ "Hello, world!" };
    std::string_view s2 { s };  // 使用 std::string 初始化
    std::cout << s2 << '\n';

    std::string_view s3 { s2 }; // 使用 std::string_view 初始化
    std::cout << s3 << '\n';

    return 0;
}
```

### `std::string_view` 参数接受多种字符串类型的参数

C 风格字符串和 `std::string` 可以隐式转换为 `std::string_view`。因此，`std::string_view` 参数可以接受 C 风格字符串、`std::string` 或 `std::string_view` 类型的参数：

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view str)
{
    std::cout << str << '\n';
}

int main()
{
    printSV("Hello, world!"); // 用 C 风格字符串字面量调用

    std::string s2{ "Hello, world!" };
    printSV(s2); // 用 std::string 调用

    std::string_view s3 { s2 };
    printSV(s3); // 用 std::string_view 调用

    return 0;
}
```

### `std::string_view` 不会隐式转换为 `std::string`

因为 `std::string` 会复制其初始化值（这是比较昂贵的操作），C++ 不允许 `std::string_view` 隐式转换为 `std::string`。这是为了防止意外将 `std::string_view` 传递给 `std::string` 参数，从而无意中进行不必要的复制。

然而，如果确实需要进行这种转换，有两种方式可选：

- 显式创建一个 `std::string`，并用 `std::string_view` 进行初始化（这种操作很少会无意间发生）
- 使用 `static_cast` 将现有的 `std::string_view` 转换为 `std::string`

以下示例展示了这两种方式：

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printString(std::string str)
{
	std::cout << str << '\n';
}

int main()
{
	std::string_view sv{ "Hello, world!" };

	// printString(sv);   // 编译错误：不会隐式转换 std::string_view 为 std::string

	std::string s{ sv }; // 可以：用 std::string_view 初始化 std::string
	printString(s);      // 然后用 std::string 调用函数

	printString(static_cast<std::string>(sv)); // 可以：可以显式将 std::string_view 转换为 std::string

	return 0;
}
```

### 赋值操作改变 `std::string_view` 正在查看的内容

将新的字符串赋值给 `std::string_view` 会使 `std::string_view` 查看新字符串。这不会以任何方式修改之前所查看的字符串。

以下例子展示了这一点：

```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string name { "Alex" };
    std::string_view sv { name }; // sv 正在查看 name
    std::cout << sv << '\n'; // 输出 Alex

    sv = "John"; // sv 现在查看的是 "John"（不会改变 name）
    std::cout << sv << '\n'; // 输出 John

    std::cout << name << '\n'; // 输出 Alex

    return 0;
}
```

在上例中，`sv = "John"` 使 `sv` 开始查看字符串 `"John"`。但这并不会改变 `name` 中的值（它仍然是 `"Alex"`）。

### `std::string_view` 的字面量

双引号括起来的字符串字面量默认是 C 风格的字符串字面量。我们可以通过在双引号后加上 `sv` 后缀来创建 `std::string_view` 字面量。`sv` 必须是小写的。

```cpp
#include <iostream>
#include <string>      // 用于 std::string
#include <string_view> // 用于 std::string_view

int main()
{
    using namespace std::string_literals;      // 访问 s 后缀
    using namespace std::string_view_literals; // 访问 sv 后缀

    std::cout << "foo\n";   // 无后缀为 C 风格字符串字面量
    std::cout << "goo\n"s;  // s 后缀为 std::string 字面量
    std::cout << "moo\n"sv; // sv 后缀为 std::string_view 字面量

    return 0;
}
```

**相关内容：**

我们在 5.9 章中讨论了如何使用 `using namespace`，同样的建议也适用于这里。

使用 C 风格字符串字面量初始化 `std::string_view` 对象是完全没问题的（不需要用 `std::

string_view` 字面量进行初始化）。

尽管如此，使用 `std::string_view` 字面量初始化 `std::string_view` 不会引发任何问题（因为这种字面量实际上是 C 风格字符串字面量的伪装）。

### `constexpr std::string_view`

与 `std::string` 不同，`std::string_view` 完全支持 `constexpr`：

```cpp
#include <iostream>
#include <string_view>

int main()
{
    constexpr std::string_view s{ "Hello, world!" }; // s 是字符串常量
    std::cout << s << '\n'; // s 会在编译时被替换为 "Hello, world!"

    return 0;
}
```

这使得 `constexpr std::string_view` 成为需要字符串常量时的首选。

我们将在下一节继续讨论 `std::string_view`。

# 5.11 `std::string_view` (part 2)
### 5.11 — `std::string_view` (第二部分)
Alex 2024年9月4日

在前几节课中，我们介绍了两种字符串类型：`std::string`（5.9 —— `std::string` 介绍）和 `std::string_view`（5.10 —— `std::string_view` 介绍）。

由于 `std::string_view` 是我们第一次接触的“视图类型”，我们将进一步讨论它的安全使用，并通过一些示例展示不正确使用的情况。最后，我们将提供一些关于何时使用 `std::string` 和 `std::string_view` 的指导。

### 所有者和查看者的介绍

我们用一个比喻来解释。假设你决定画一幅自行车的画，但是你没有自行车。你该怎么办？

你可以去附近的自行车店买一辆。这时你将拥有这辆车。拥有这辆车有一些好处：你可以骑它、随时使用它、装饰它，或者移动它。当然，拥有它也有一些缺点：自行车可能很贵，你还得维护它，并在不需要时处理掉它。

拥有东西的代价很高，作为所有者，你有责任获取、管理和妥善处理你拥有的对象。

然而，你也可以从窗外看到你邻居的自行车，拍下照片，而不需要买一辆自己的车。这种情况下，你只是在“查看”这辆车，它带来了许多好处：不需要花钱购买，也不用维护或处理它。但同样的，你也无法改变邻居的车的外观或控制它的去留。你的视角可能随时发生变化，可能看到的是意料之外的东西。

**查看**是廉价的。作为查看者，你没有责任管理对象，但也无法控制它们。

### `std::string` 是所有者

`std::string` 类是所有者。它创建并管理自己的数据副本，不依赖于初始化值，这确保了在初始化完成后，`std::string` 可以独立存在，即使初始化值被修改或销毁。

### 我们并不总是需要一个副本

回顾前面的例子：

```cpp
#include <iostream>
#include <string>

void printString(std::string str) // str 复制了初始化值
{
    std::cout << str << '\n';
}

int main()
{
    std::string s{ "Hello, world!" };
    printString(s);

    return 0;
}
```

这里 `str` 会复制 `s`，这会造成不必要的开销。如果我们确定初始化的字符串 `s` 不会在 `str` 使用时被修改或销毁，那么完全可以避免这种复制，直接使用 `s`。`std::string_view` 就提供了这种机制。

### `std::string_view` 是查看者

`std::string_view` 是一种视图类型，它不会复制初始化字符串，而是创建对该字符串的只读视图。当视图被销毁时，原始对象不会受到影响。

不过，`std::string_view` 依赖于初始化字符串的生命周期。如果初始化字符串在 `std::string_view` 还在使用时被修改或销毁，将导致意外或未定义的行为。

### `std::string_view` 最适合作为只读函数参数

`std::string_view` 最佳用途是作为函数的只读参数，它可以接收 C 风格字符串、`std::string` 或 `std::string_view`，而无需复制：

```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view str)
{
    std::cout << str << '\n';
}

int main()
{
    printSV("Hello, world!");  // 使用 C 风格字符串字面量
    std::string s2{ "Hello, world!" };
    printSV(s2);               // 使用 std::string
    std::string_view s3 { s2 };
    printSV(s3);               // 使用 std::string_view

    return 0;
}
```

### 不当使用 `std::string_view`

以下是两个不正确使用 `std::string_view` 的例子。

#### 示例1：访问已经销毁的字符串

```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string_view sv{};
    { 
        std::string s{ "Hello, world!" };
        sv = s;  // sv 正在查看 s
    } 
    std::cout << sv << '\n'; // 未定义行为：s 已被销毁

    return 0;
}
```

在这个例子中，`s` 在嵌套块结束时被销毁，而 `sv` 仍然尝试访问已经销毁的 `s`，这会导致未定义的行为。

#### 示例2：初始化自临时字符串

```cpp
#include <iostream>
#include <string>
#include <string_view>

std::string getName()
{
    std::string s{ "Alex" };
    return s;
}

int main()
{
    std::string_view name { getName() }; // name 查看临时对象
    std::cout << name << '\n';           // 未定义行为

    return 0;
}
```

返回的 `std::string` 是临时对象，它在表达式结束时被销毁，导致 `name` 成为悬空视图，后续访问会产生未定义行为。

### 何时使用 `std::string` vs `std::string_view`

#### 使用 `std::string` 的情况：
- 需要修改字符串。
- 需要存储用户输入的文本。
- 需要存储函数返回的 `std::string`。

#### 使用 `std::string_view` 的情况：
- 只需要读取现有的字符串，且不会修改或销毁它。
- 需要符号常量。

#### 使用 `std::string_view` 作为函数参数的情况：
- 函数只需要只读访问字符串，不需要修改。

#### 使用 `std::string` 作为返回值的情况：
- 返回的是局部 `std::string` 变量或函数参数。

#### 使用 `std::string_view` 作为返回值的情况：
- 返回的是 C 风格字符串或 `std::string_view` 参数。

### 结论

`std::string_view` 是一种高效的工具，适用于避免不必要的字符串复制，但使用时需谨慎，确保视图不会指向已经销毁或修改的字符串。

# 5.x Chapter 5 summary and quiz

### 第五章总结与测验

---

#### **章节总结：**

1. **常量与变量**：
    - **常量**是指在程序执行期间不可更改的值。C++ 支持两种类型的常量：**命名常量**（与标识符相关联）和**字面常量**（直接写在代码中的值）。
    - **常量变量**是一个值不可更改的变量，使用 `const` 关键字声明。常量变量必须在声明时初始化。避免在传值或返回值时使用 `const`。

2. **类型限定符**：
    - **类型限定符**是应用于类型的关键字，用于修改该类型的行为。截至 C++23，C++ 仅支持 `const` 和 `volatile` 作为类型限定符。

3. **常量表达式**：
    - **常量表达式**是可以在编译时计算的表达式。如果一个表达式不是常量表达式，通常称为运行时表达式。
    - **编译时常量**是指在编译时已知其值的常量，而**运行时常量**是在运行时初始化其值的常量。

4. **constexpr 变量**：
    - **constexpr 变量**必须是编译时常量，且必须使用常量表达式初始化。函数参数不能为 `constexpr`。

5. **字面量**：
    - 字面量是直接插入代码中的值。字面量有类型，可以使用字面量后缀来改变字面量的默认类型。

6. **魔法数字**：
    - **魔法数字**是指在代码中含义不清或可能需要更改的字面量（通常是数字）。在代码中不要使用魔法数字，应使用符号常量代替。

7. **进制系统**：
    - 在日常生活中，我们使用十进制数，它包含10个数字。计算机使用二进制数，仅包含2个数字。C++ 还支持八进制（8进制）和十六进制（16进制），这些都是数字系统的示例，即用于表示数字的符号集合。

8. **条件运算符 (?:)**：
    - **条件运算符**（也称为三元运算符）是一个接受三个操作数的运算符。条件表达式的格式为 `c ? x : y`，如果条件 `c` 为真，则 `x` 将被计算；否则，`y` 将被计算。通常需要给条件运算符添加括号：
        - 当在复合表达式中使用时，需要对整个条件运算符进行括号包围。
        - 如果条件包含其他运算符（除函数调用运算符外），为了可读性，建议将条件括起来。

9. **内联展开**：
    - **内联展开**是将函数调用替换为该函数定义中的代码的过程。用 `inline` 关键字声明的函数称为内联函数。

10. **内联函数与内联变量的要求**：
    - 编译器需要能够在每个使用内联函数的翻译单元中看到该函数的完整定义（仅前向声明不足以满足需求）。如果提供了前向声明，定义可以在使用点之后出现。
    - 内联函数或变量的每个定义必须是相同的，否则会导致未定义行为。

11. **constexpr 函数**：
    - **constexpr 函数**是返回值可以在编译时计算的函数。要将函数声明为 constexpr，只需在返回类型前添加 `constexpr` 关键字。
    - Constexpr 函数仅在需要常量表达式的上下文中才保证在编译时计算，否则它们可以在编译时（如果符合条件）或运行时计算。

12. **consteval 函数**：
    - **consteval 函数**是必须在编译时计算的函数。

13. **内联**：
    - Constexpr 和 consteval 函数都隐式为内联函数。

14. **字符串**：
    - **字符串**是一系列顺序的字符，用于表示文本（如名称、单词和句子）。字符串字面量总是用双引号括起来。C++ 中的字符串字面量是 C 风格字符串，其类型较为复杂，难以操作。

15. **std::string**：
    - `std::string` 提供了一种处理文本字符串的简单安全的方式。`std::string` 位于 `<string>` 头文件中。`std::string` 初始化（或赋值）和复制的开销较大。

16. **std::string_view**：
    - `std::string_view` 提供对已有字符串（C 风格字符串字面量、`std::string` 或字符数组）的只读访问，而无需复制。如果 `std::string_view` 正在查看的字符串被销毁，这种情况称为**悬挂视图**。
    - 当修改 `std::string` 时，所有指向该字符串的视图都会失效，使用失效的视图（除非对其重新验证）将导致未定义行为。

17. **子字符串**：
    - **子字符串**是指在现有字符串中的一段连续字符序列。

---

#### **测验时间**

**问题 1**  
为什么命名常量通常比字面常量更好？  
为什么 const/constexpr 变量通常比 `#define` 定义的符号常量更好？

**问题 2**  
找出以下代码中的 3 个问题：

```cpp
#include <cstdint> // for std::uint8_t
#include <iostream>

int main()
{
  std::cout << "How old are you?\n";

  std::uint8_t age{};
  std::cin >> age;

  std::cout << "Allowed to drive a car in Texas: ";

  if (age >= 16)
      std::cout << "Yes";
  else
      std::cout << "No";

  std::cout << '.\n';

  return 0;
}
```

**问题 3**  
将 `const` 和/或 `constexpr` 添加到以下程序中：

```cpp
#include <iostream>

// gets tower height from user and returns it
double getTowerHeight()
{
	std::cout << "Enter the height of the tower in meters: ";
	double towerHeight{};
	std::cin >> towerHeight;
	return towerHeight;
}

// Returns ball height from ground after "seconds" seconds
double calculateBallHeight(double towerHeight, int seconds)
{
	double gravity{ 9.8 };

	// Using formula: [ s = u * t + (a * t^2) / 2 ], here u(initial velocity) = 0
	double distanceFallen{ (gravity * (seconds * seconds)) / 2.0 };
	double currentHeight{ towerHeight - distanceFallen };

	return currentHeight;
}

// Prints ball height above ground
void printBallHeight(double ballHeight, int seconds)
{
	if (ballHeight > 0.0)
		std::cout << "At " << seconds << " seconds, the ball is at height: " << ballHeight << " meters\n";
	else
		std::cout << "At " << seconds << " seconds, the ball is on the ground.\n";
}

// Calculates the current ball height and then prints it
// This is a helper function to make it easier to do this
void printCalculatedBallHeight(double towerHeight, int seconds)
{
	double ballHeight{ calculateBallHeight(towerHeight, seconds) };
	printBallHeight(ballHeight, seconds);
}

int main()
{
	double towerHeight{ getTowerHeight() };

	printCalculatedBallHeight(towerHeight, 0);
	printCalculatedBallHeight(towerHeight, 1);
	printCalculatedBallHeight(towerHeight, 2);
	printCalculatedBallHeight(towerHeight, 3);
	printCalculatedBallHeight(towerHeight, 4);
	printCalculatedBallHeight(towerHeight, 5);

	return 0;
}
```

